var ot=Object.defineProperty;var rt=(e,t,o)=>t in e?ot(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var S=(e,t,o)=>rt(e,typeof t!="symbol"?t+"":t,o);import{r as w}from"./react-vendor-BdF-CjAN.js";import{s as nt,d as z,a as U,t as st,b as k,m as at,c as it,o as ct,e as lt}from"./tensorflow-obHFcFBr.js";const ut=(e,t)=>t.some(o=>e instanceof o);let H,$;function dt(){return H||(H=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function mt(){return $||($=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const q=new WeakMap,_=new WeakMap,Q=new WeakMap,v=new WeakMap,j=new WeakMap;function ft(e){const t=new Promise((o,r)=>{const n=()=>{e.removeEventListener("success",l),e.removeEventListener("error",a)},l=()=>{o(L(e.result)),n()},a=()=>{r(e.error),n()};e.addEventListener("success",l),e.addEventListener("error",a)});return t.then(o=>{o instanceof IDBCursor&&q.set(o,e)}).catch(()=>{}),j.set(t,e),t}function ht(e){if(_.has(e))return;const t=new Promise((o,r)=>{const n=()=>{e.removeEventListener("complete",l),e.removeEventListener("error",a),e.removeEventListener("abort",a)},l=()=>{o(),n()},a=()=>{r(e.error||new DOMException("AbortError","AbortError")),n()};e.addEventListener("complete",l),e.addEventListener("error",a),e.addEventListener("abort",a)});_.set(e,t)}let W={get(e,t,o){if(e instanceof IDBTransaction){if(t==="done")return _.get(e);if(t==="objectStoreNames")return e.objectStoreNames||Q.get(e);if(t==="store")return o.objectStoreNames[1]?void 0:o.objectStore(o.objectStoreNames[0])}return L(e[t])},set(e,t,o){return e[t]=o,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function gt(e){W=e(W)}function pt(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...o){const r=e.call(N(this),t,...o);return Q.set(r,t.sort?t.sort():[t]),L(r)}:mt().includes(e)?function(...t){return e.apply(N(this),t),L(q.get(this))}:function(...t){return L(e.apply(N(this),t))}}function yt(e){return typeof e=="function"?pt(e):(e instanceof IDBTransaction&&ht(e),ut(e,dt())?new Proxy(e,W):e)}function L(e){if(e instanceof IDBRequest)return ft(e);if(v.has(e))return v.get(e);const t=yt(e);return t!==e&&(v.set(e,t),j.set(t,e)),t}const N=e=>j.get(e);function wt(e,t,{blocked:o,upgrade:r,blocking:n,terminated:l}={}){const a=indexedDB.open(e,t),s=L(a);return r&&a.addEventListener("upgradeneeded",c=>{r(L(a.result),c.oldVersion,c.newVersion,L(a.transaction),c)}),o&&a.addEventListener("blocked",c=>o(c.oldVersion,c.newVersion,c)),s.then(c=>{l&&c.addEventListener("close",()=>l()),n&&c.addEventListener("versionchange",d=>n(d.oldVersion,d.newVersion,d))}).catch(()=>{}),s}const bt=["get","getKey","getAll","getAllKeys","count"],St=["put","add","delete","clear"],F=new Map;function V(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(F.get(t))return F.get(t);const o=t.replace(/FromIndex$/,""),r=t!==o,n=St.includes(o);if(!(o in(r?IDBIndex:IDBObjectStore).prototype)||!(n||bt.includes(o)))return;const l=async function(a,...s){const c=this.transaction(a,n?"readwrite":"readonly");let d=c.store;return r&&(d=d.index(s.shift())),(await Promise.all([d[o](...s),n&&c.done]))[0]};return F.set(t,l),l}gt(e=>({...e,get:(t,o,r)=>V(t,o)||e.get(t,o,r),has:(t,o)=>!!V(t,o)||e.has(t,o)}));const Et=1,Ct="echoroom-db",g={ROOMS:"rooms",SAMPLES:"samples",MODEL:"model"};let M=null;async function b(){return M||(M=await wt(Ct,Et,{upgrade(e,t,o,r){if(console.log(`Upgrading database from v${t} to v${o}`),!e.objectStoreNames.contains(g.ROOMS)){const n=e.createObjectStore(g.ROOMS,{keyPath:"id"});n.createIndex("by-name","name"),n.createIndex("by-created","createdAt")}if(!e.objectStoreNames.contains(g.SAMPLES)){const n=e.createObjectStore(g.SAMPLES,{keyPath:"id"});n.createIndex("by-room","roomId"),n.createIndex("by-captured","capturedAt")}e.objectStoreNames.contains(g.MODEL)||e.createObjectStore(g.MODEL,{keyPath:"id"})},blocked(){console.warn("Database upgrade blocked - close other tabs")},blocking(){M==null||M.close(),M=null},terminated(){console.error("Database connection terminated unexpectedly"),M=null}}),M)}let O;const Mt=new Uint8Array(16);function Lt(){if(!O&&(O=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!O))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return O(Mt)}const y=[];for(let e=0;e<256;++e)y.push((e+256).toString(16).slice(1));function Rt(e,t=0){return y[e[t+0]]+y[e[t+1]]+y[e[t+2]]+y[e[t+3]]+"-"+y[e[t+4]]+y[e[t+5]]+"-"+y[e[t+6]]+y[e[t+7]]+"-"+y[e[t+8]]+y[e[t+9]]+"-"+y[e[t+10]]+y[e[t+11]]+y[e[t+12]]+y[e[t+13]]+y[e[t+14]]+y[e[t+15]]}const At=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),G={randomUUID:At};function Z(e,t,o){if(G.randomUUID&&!e)return G.randomUUID();e=e||{};const r=e.random||(e.rng||Lt)();return r[6]=r[6]&15|64,r[8]=r[8]&63|128,Rt(r)}async function It(e,t){const o=await b(),r={id:Z(),name:e.trim(),icon:t==null?void 0:t.icon,color:t==null?void 0:t.color,createdAt:Date.now(),updatedAt:Date.now()};return await o.add(g.ROOMS,r),r}async function Dt(e){return(await b()).get(g.ROOMS,e)}async function Ot(){return(await b()).getAll(g.ROOMS)}async function Pt(e,t){const o=await b(),r=await o.get(g.ROOMS,e);if(!r)return;const n={...r,...t,updatedAt:Date.now()};return await o.put(g.ROOMS,n),n}async function xt(e){const o=(await b()).transaction([g.ROOMS,g.SAMPLES],"readwrite");let l=await o.objectStore(g.SAMPLES).index("by-room").openCursor(IDBKeyRange.only(e));for(;l;)await l.delete(),l=await l.continue();return await o.objectStore(g.ROOMS).delete(e),await o.done,!0}async function Y(e){return await(await b()).getFromIndex(g.ROOMS,"by-name",e.trim())!==void 0}async function Ut(e,t,o){const r=await b(),n={id:Z(),roomId:e,features:t,metadata:o,capturedAt:Date.now()};return await r.add(g.SAMPLES,n),n}async function Ht(e){return(await b()).getAllFromIndex(g.SAMPLES,"by-room",e)}async function $t(){return(await b()).getAll(g.SAMPLES)}async function tt(){const t=await(await b()).getAll(g.SAMPLES),o=new Map;for(const r of t){const n=o.get(r.roomId)||0;o.set(r.roomId,n+1)}return o}async function Vt(e){return await(await b()).delete(g.SAMPLES,e),!0}async function Gt(e){const o=(await b()).transaction(g.SAMPLES,"readwrite");let n=await o.store.index("by-room").openCursor(IDBKeyRange.only(e)),l=0;for(;n;)await n.delete(),l++,n=await n.continue();return await o.done,l}async function Yt(){const t=await(await b()).getAll(g.SAMPLES),o=[],r=[],n=new Set;for(const l of t)o.push(l.features),r.push(l.roomId),n.add(l.roomId);return{features:o,labels:r,roomIds:Array.from(n)}}async function Kt(e=5){const t=await tt(),o=t.size;let r=0,n=0;for(const s of t.values())n+=s,s>=e&&r++;const l=r>=2;let a;return o<2?a=`Need at least 2 rooms (have ${o})`:r<2?a=`Need at least 2 rooms with ${e}+ samples (have ${r})`:a=`Ready to train with ${r} rooms and ${n} samples`,{canTrain:l,roomCount:o,readyRooms:r,totalSamples:n,message:a}}const P="current";async function Tt(e,t,o,r,n){const l=await b(),a={id:P,topology:e,weights:t,roomLabels:o,normalizer:r,metadata:n,createdAt:Date.now()};return await l.put(g.MODEL,a),a}async function et(){return(await b()).get(g.MODEL,P)}async function zt(){return await et()!==void 0}async function vt(){const e=await b();return await e.get(g.MODEL,P)?(await e.delete(g.MODEL,P),!0):!1}function Jt(){const[e,t]=w.useState({rooms:[],isLoading:!0,error:null}),o=w.useCallback(async()=>{t(s=>({...s,isLoading:!0,error:null}));try{const[s,c]=await Promise.all([Ot(),tt()]),d=s.map(i=>({...i,sampleCount:c.get(i.id)||0}));d.sort((i,u)=>u.createdAt-i.createdAt),t({rooms:d,isLoading:!1,error:null})}catch(s){const c=s instanceof Error?s.message:"Failed to load rooms";t(d=>({...d,isLoading:!1,error:c}))}},[]);w.useEffect(()=>{o()},[o]);const r=w.useCallback(async(s,c)=>{try{if(await Y(s))return t(u=>({...u,error:`A room named "${s}" already exists`})),null;const i=await It(s,c);return t(u=>({...u,rooms:[{...i,sampleCount:0},...u.rooms],error:null})),i}catch(d){const i=d instanceof Error?d.message:"Failed to create room";return t(u=>({...u,error:i})),null}},[]),n=w.useCallback(async(s,c)=>{try{if(c.name){const i=await Dt(s);if(i&&i.name!==c.name&&await Y(c.name))return t(m=>({...m,error:`A room named "${c.name}" already exists`})),!1}const d=await Pt(s,c);return d?(t(i=>({...i,rooms:i.rooms.map(u=>u.id===s?{...u,...d}:u),error:null})),!0):(t(i=>({...i,error:"Room not found"})),!1)}catch(d){const i=d instanceof Error?d.message:"Failed to update room";return t(u=>({...u,error:i})),!1}},[]),l=w.useCallback(async s=>{try{return await xt(s),t(c=>({...c,rooms:c.rooms.filter(d=>d.id!==s),error:null})),!0}catch(c){const d=c instanceof Error?c.message:"Failed to delete room";return t(i=>({...i,error:d})),!1}},[]),a=w.useCallback(s=>e.rooms.find(c=>c.id===s),[e.rooms]);return{state:e,addRoom:r,editRoom:n,removeRoom:l,refreshRooms:o,getRoomById:a}}const Nt={inputSize:60,hiddenLayers:[128,64,32],dropoutRates:[.3,.2,0],learningRate:.001},Ft={epochs:100,batchSize:32,validationSplit:.2,earlyStopping:{patience:10,minDelta:.001},classWeights:!0,augmentation:{enabled:!0,noiseStd:.05}},B={LOW_CONFIDENCE_PROBABILITY:.6,HIGH_ENTROPY_THRESHOLD:1,MIN_MARGIN_THRESHOLD:.2};class x{constructor(t){S(this,"mean");S(this,"std");S(this,"featureCount");S(this,"fitted",!1);t?(this.mean=t.mean,this.std=t.std,this.featureCount=t.featureCount,this.fitted=!0):(this.mean=[],this.std=[],this.featureCount=0)}fit(t){if(t.length===0)throw new Error("Cannot fit normalizer with empty data");this.featureCount=t[0].length;const o=t.length;this.mean=new Array(this.featureCount).fill(0),this.std=new Array(this.featureCount).fill(0);for(const r of t)for(let n=0;n<this.featureCount;n++)this.mean[n]+=r[n];for(let r=0;r<this.featureCount;r++)this.mean[r]/=o;for(const r of t)for(let n=0;n<this.featureCount;n++){const l=r[n]-this.mean[n];this.std[n]+=l*l}for(let r=0;r<this.featureCount;r++)this.std[r]=Math.sqrt(this.std[r]/o),this.std[r]<1e-10&&(this.std[r]=1);this.fitted=!0}transform(t){if(!this.fitted)throw new Error("Normalizer must be fitted before transform");if(t.length!==this.featureCount)throw new Error(`Feature count mismatch: expected ${this.featureCount}, got ${t.length}`);const o=new Array(this.featureCount);for(let r=0;r<this.featureCount;r++)o[r]=(t[r]-this.mean[r])/this.std[r];return o}transformBatch(t){return t.map(o=>this.transform(o))}fitTransform(t){return this.fit(t),this.transformBatch(t)}inverseTransform(t){if(!this.fitted)throw new Error("Normalizer must be fitted before inverse transform");const o=new Array(this.featureCount);for(let r=0;r<this.featureCount;r++)o[r]=t[r]*this.std[r]+this.mean[r];return o}getParams(){if(!this.fitted)throw new Error("Normalizer must be fitted before getting params");return{mean:[...this.mean],std:[...this.std],featureCount:this.featureCount}}isFitted(){return this.fitted}static fromParams(t){return new x(t)}}function Bt(e){let t=0;for(const o of e)o>1e-10&&(t-=o*Math.log2(o));return t}function kt(e){if(e.length<2)return 1;const t=[...e].sort((o,r)=>r-o);return t[0]-t[1]}function K(e){const t=Math.max(...e),o=Bt(e),r=kt(e),n=t<B.LOW_CONFIDENCE_PROBABILITY||o>B.HIGH_ENTROPY_THRESHOLD||r<B.MIN_MARGIN_THRESHOLD;return{topProbability:t,entropy:o,margin:r,isLowConfidence:n}}class J{constructor(t){S(this,"model",null);S(this,"normalizer",null);S(this,"roomLabels",[]);S(this,"config");S(this,"isReady",!1);this.config={...Nt,numClasses:(t==null?void 0:t.numClasses)??2,...t}}buildModel(t){const{inputSize:o,hiddenLayers:r,dropoutRates:n,learningRate:l}=this.config,a=nt();a.add(z({units:r[0],activation:"relu",inputShape:[o],kernelInitializer:"heNormal"})),n[0]>0&&a.add(U({rate:n[0]}));for(let s=1;s<r.length;s++)a.add(z({units:r[s],activation:"relu",kernelInitializer:"heNormal"})),n[s]>0&&a.add(U({rate:n[s]}));return a.add(z({units:t,activation:"softmax",kernelInitializer:"glorotNormal"})),a.compile({optimizer:st.adam(l),loss:"categoricalCrossentropy",metrics:["accuracy"]}),a}initialize(t,o,r){this.roomLabels=t,this.normalizer=o,this.config.numClasses=t.length,r?this.model=r:this.model=this.buildModel(t.length),this.isReady=!0}async predict(t){if(!this.isReady||!this.model||!this.normalizer)throw new Error("Classifier not initialized. Call initialize() first.");const o=this.normalizer.transform(t),r=k([o]),n=this.model.predict(r),l=await n.data();r.dispose(),n.dispose();let a=0,s=0;const c=new Map;for(let i=0;i<l.length;i++){const u=l[i],m=this.roomLabels[i];c.set(m,u),u>a&&(a=u,s=i)}const d=K(Array.from(l));return{predictedRoomId:this.roomLabels[s],confidence:a,allProbabilities:c,isLowConfidence:d.isLowConfidence,entropy:d.entropy}}async predictWithUncertainty(t,o=10){if(!this.isReady||!this.model||!this.normalizer)throw new Error("Classifier not initialized.");const r=this.normalizer.transform(t),n=k([r]),l=[];for(let f=0;f<o;f++){const h=this.model.predict(n),p=await h.data();l.push(Array.from(p)),h.dispose()}n.dispose();const a=new Array(this.roomLabels.length).fill(0);for(const f of l)for(let h=0;h<f.length;h++)a[h]+=f[h];for(let f=0;f<a.length;f++)a[f]/=o;let s=0;for(const f of l)for(let h=0;h<f.length;h++){const p=f[h]-a[h];s+=p*p}const c=Math.sqrt(s/(o*this.roomLabels.length));let d=0,i=0;const u=new Map;for(let f=0;f<a.length;f++){const h=a[f];u.set(this.roomLabels[f],h),h>d&&(d=h,i=f)}const m=K(a);return{predictedRoomId:this.roomLabels[i],confidence:d,allProbabilities:u,isLowConfidence:m.isLowConfidence,entropy:m.entropy,uncertainty:c}}getModel(){return this.model}getRoomLabels(){return[...this.roomLabels]}getNormalizer(){return this.normalizer}ready(){return this.isReady}async serialize(){if(!this.model)throw new Error("No model to serialize");const t=this.model.toJSON(),o=await this.model.getWeights(),r=[];for(const s of o){const c=await s.data();r.push(new Float32Array(c))}const n=r.reduce((s,c)=>s+c.length,0),l=new Float32Array(n);let a=0;for(const s of r)l.set(s,a),a+=s.length;return{topology:t,weights:l.buffer}}async deserialize(t,o,r,n){this.model=await at(t);const l=new Float32Array(o),a=this.model.getWeights();let s=0;const c=[];for(const d of a){const i=d.shape,u=i.reduce((f,h)=>f*h,1),m=l.slice(s,s+u);c.push(it(m,i)),s+=u}this.model.setWeights(c);for(const d of c)d.dispose();this.roomLabels=r,this.normalizer=x.fromParams(n),this.config.numClasses=r.length,this.isReady=!0}dispose(){this.model&&(this.model.dispose(),this.model=null),this.isReady=!1}}class X{constructor(t){S(this,"config");S(this,"progressCallback");this.config={...Ft,...t}}onProgress(t){this.progressCallback=t}reportProgress(t){this.progressCallback&&this.progressCallback(t)}prepareData(t,o,r){this.reportProgress({epoch:0,totalEpochs:this.config.epochs,loss:0,accuracy:0,phase:"preparing",message:"Normalizing features..."});const n=new x,l=n.fitTransform(t);let a=l,s=o;if(this.config.augmentation.enabled){this.reportProgress({epoch:0,totalEpochs:this.config.epochs,loss:0,accuracy:0,phase:"preparing",message:"Augmenting data..."});const{features:m,labels:f}=this.augmentData(l,o);a=m,s=f}const c=s.map(m=>r.indexOf(m)),d=r.length,i=k(a),u=ct(lt(c,"int32"),d);return{normalizer:n,trainX:i,trainY:u}}augmentData(t,o){const r=[...t],n=[...o],l=this.config.augmentation.noiseStd;for(let a=0;a<t.length;a++){const s=t[a].map(c=>c+(Math.random()-.5)*2*l);r.push(s),n.push(o[a])}return{features:r,labels:n}}computeClassWeights(t,o){const r=new Map;for(const s of t)r.set(s,(r.get(s)||0)+1);const n=t.length,l=o.length,a={};for(let s=0;s<o.length;s++){const c=r.get(o[s])||1;a[s]=n/(l*c)}return a}async train(t,o,r,n){var l,a;try{const{normalizer:s,trainX:c,trainY:d}=this.prepareData(o,r,n);t.initialize(n,s);const i=t.getModel();if(!i)throw new Error("Failed to create model");let u;this.config.classWeights&&(u=this.computeClassWeights(r,n));const m={loss:[],accuracy:[],valLoss:[],valAccuracy:[]};let f=1/0,h=0;this.reportProgress({epoch:0,totalEpochs:this.config.epochs,loss:0,accuracy:0,phase:"training",message:"Starting training..."});for(let C=0;C<this.config.epochs;C++){const R=await i.fit(c,d,{epochs:1,batchSize:this.config.batchSize,validationSplit:this.config.validationSplit,classWeight:u,shuffle:!0,verbose:0}),I=R.history.loss[0],T=R.history.acc[0],A=(l=R.history.val_loss)==null?void 0:l[0],D=(a=R.history.val_acc)==null?void 0:a[0];if(m.loss.push(I),m.accuracy.push(T),A!==void 0&&m.valLoss.push(A),D!==void 0&&m.valAccuracy.push(D),this.reportProgress({epoch:C+1,totalEpochs:this.config.epochs,loss:I,accuracy:T,valLoss:A,valAccuracy:D,phase:"training"}),A!==void 0){if(A<f-this.config.earlyStopping.minDelta)f=A,h=0;else if(h++,h>=this.config.earlyStopping.patience){this.reportProgress({epoch:C+1,totalEpochs:this.config.epochs,loss:I,accuracy:T,valLoss:A,valAccuracy:D,phase:"complete",message:`Early stopping at epoch ${C+1}`});break}}}c.dispose(),d.dispose();const p=m.valAccuracy.length>0?m.valAccuracy[m.valAccuracy.length-1]:m.accuracy[m.accuracy.length-1],E=m.valLoss.length>0?m.valLoss[m.valLoss.length-1]:m.loss[m.loss.length-1];return this.reportProgress({epoch:m.loss.length,totalEpochs:this.config.epochs,loss:E,accuracy:p,phase:"complete",message:`Training complete! Accuracy: ${(p*100).toFixed(1)}%`}),{success:!0,finalAccuracy:p,finalLoss:E,epochs:m.loss.length,history:m}}catch(s){const c=s instanceof Error?s.message:"Unknown error";return this.reportProgress({epoch:0,totalEpochs:this.config.epochs,loss:0,accuracy:0,phase:"error",message:`Training failed: ${c}`}),{success:!1,finalAccuracy:0,finalLoss:0,epochs:0,history:{loss:[],accuracy:[],valLoss:[],valAccuracy:[]},error:c}}}async evaluate(t,o,r){const n=t.getRoomLabels(),l=n.length,a=Array(l).fill(null).map(()=>Array(l).fill(0));let s=0;for(let c=0;c<o.length;c++){const d=await t.predict(o[c]),i=n.indexOf(d.predictedRoomId),u=n.indexOf(r[c]);a[u][i]++,i===u&&s++}return{accuracy:s/o.length,confusionMatrix:a}}}function Xt(){const[e,t]=w.useState({modelState:"none",isTraining:!1,trainingProgress:null,lastTrainingResult:null,modelInfo:null,error:null}),o=w.useRef(null),r=w.useRef(null);w.useEffect(()=>(r.current=new X,n(),()=>{o.current&&o.current.dispose()}),[]);const n=async()=>{t(i=>({...i,modelState:"loading",error:null}));try{const i=await et();if(!i)return t(m=>({...m,modelState:"none"})),!1;const u=new J;return await u.deserialize(i.topology,i.weights,i.roomLabels,i.normalizer),o.current=u,t(m=>({...m,modelState:"ready",modelInfo:{roomCount:i.roomLabels.length,accuracy:i.metadata.accuracy,createdAt:i.createdAt}})),!0}catch(i){const u=i instanceof Error?i.message:"Failed to load model";return console.error("Failed to load model:",i),t(m=>({...m,modelState:"error",error:u})),!1}},l=w.useCallback(async(i,u,m)=>{t(f=>({...f,modelState:"training",isTraining:!0,trainingProgress:null,lastTrainingResult:null,error:null}));try{o.current&&o.current.dispose();const f=new J,h=r.current||new X;h.onProgress(E=>{t(C=>({...C,trainingProgress:E}))});const p=await h.train(f,i,u,m);if(p.success){const{topology:E,weights:C}=await f.serialize(),R=f.getNormalizer();R&&await Tt(E,C,m,R.getParams(),{accuracy:p.finalAccuracy,loss:p.finalLoss,epochs:p.epochs,samplesUsed:i.length,roomCount:m.length}),o.current=f,t(I=>({...I,modelState:"ready",isTraining:!1,lastTrainingResult:p,modelInfo:{roomCount:m.length,accuracy:p.finalAccuracy,createdAt:Date.now()}}))}else t(E=>({...E,modelState:"error",isTraining:!1,lastTrainingResult:p,error:p.error||"Training failed"}));return p}catch(f){const h=f instanceof Error?f.message:"Training failed",p={success:!1,finalAccuracy:0,finalLoss:0,epochs:0,history:{loss:[],accuracy:[],valLoss:[],valAccuracy:[]},error:h};return t(E=>({...E,modelState:"error",isTraining:!1,lastTrainingResult:p,error:h})),p}},[]),a=w.useCallback(async i=>{if(!o.current||!o.current.ready())return t(u=>({...u,error:"No model loaded. Train a model first."})),null;try{return await o.current.predict(i)}catch(u){const m=u instanceof Error?u.message:"Prediction failed";return t(f=>({...f,error:m})),null}},[]),s=w.useCallback(async()=>n(),[]),c=w.useCallback(async()=>{try{return await vt(),o.current&&(o.current.dispose(),o.current=null),t(i=>({...i,modelState:"none",modelInfo:null,lastTrainingResult:null,error:null})),!0}catch(i){const u=i instanceof Error?i.message:"Failed to clear model";return t(m=>({...m,error:u})),!1}},[]),d=w.useCallback(async()=>await zt(),[]);return{state:e,train:l,predict:a,loadModel:s,clearModel:c,hasTrainedModel:d}}export{Xt as a,Ut as b,Kt as c,Vt as d,Gt as e,Ht as f,$t as g,Yt as h,Jt as u};
//# sourceMappingURL=useRoomClassifier-C-Gjq7GR.js.map
