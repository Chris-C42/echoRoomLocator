{"version":3,"file":"useAudioEngine-DEbr_Whe.js","sources":["../../src/audio/types.ts","../../src/audio/ChirpGenerator.ts","../../src/audio/AudioCapture.ts","../../src/audio/utils.ts","../../src/audio/ImpulseResponseExtractor.ts","../../src/audio/FeatureExtractor.ts","../../src/hooks/useAudioEngine.ts"],"sourcesContent":["/**\n * Audio module type definitions\n */\n\nexport type ChirpMode = 'audible' | 'ultrasonic';\n\nexport interface ChirpConfig {\n  mode: ChirpMode;\n  startFrequency: number;  // Hz\n  endFrequency: number;    // Hz\n  duration: number;        // seconds\n  sampleRate: number;      // Hz\n  fadeTime: number;        // seconds (fade in/out to prevent clicks)\n}\n\nexport const CHIRP_PRESETS: Record<ChirpMode, Omit<ChirpConfig, 'sampleRate'>> = {\n  audible: {\n    mode: 'audible',\n    startFrequency: 200,\n    endFrequency: 18000,\n    duration: 0.5,\n    fadeTime: 0.01,\n  },\n  ultrasonic: {\n    mode: 'ultrasonic',\n    startFrequency: 15000,\n    endFrequency: 20000,\n    duration: 0.3,\n    fadeTime: 0.005,\n  },\n};\n\nexport interface CaptureConfig {\n  sampleRate: number;\n  duration: number;        // Total capture duration (chirp + reverb tail)\n  preDelay: number;        // Time before chirp playback starts\n}\n\nexport const DEFAULT_CAPTURE_CONFIG: CaptureConfig = {\n  sampleRate: 48000,\n  duration: 2.0,           // 2 seconds total capture\n  preDelay: 0.1,           // 100ms before chirp\n};\n\nexport interface AudioCaptureResult {\n  captured: Float32Array;  // Recorded audio\n  chirp: Float32Array;     // Original chirp for deconvolution\n  sampleRate: number;\n  config: ChirpConfig;\n  timestamp: number;\n}\n\nexport interface ImpulseResponse {\n  data: Float32Array;      // Impulse response signal\n  sampleRate: number;\n  duration: number;        // Duration in seconds\n}\n\nexport interface FeatureVector {\n  // Reverberation characteristics\n  rt60: number;            // Reverberation time (T60) in seconds\n  edt: number;             // Early decay time in seconds\n\n  // Clarity ratios\n  c50: number;             // Clarity ratio (50ms)\n  c80: number;             // Clarity ratio (80ms)\n\n  // Spectral features\n  spectralCentroid: number;\n  spectralRolloff: number;\n  spectralFlux: number;\n  spectralFlatness: number;\n\n  // MFCC coefficients (13 coefficients, mean and variance)\n  mfccMean: number[];      // 13 values\n  mfccVariance: number[];  // 13 values\n\n  // Early reflection energy (8 time bins, 0-80ms in 10ms steps)\n  earlyReflections: number[];\n\n  // Octave band energy (125Hz, 250Hz, 500Hz, 1kHz, 2kHz, 4kHz, 8kHz)\n  octaveBands: number[];\n\n  // Raw feature array for ML input\n  raw: number[];\n}\n\n// Feature vector length: 1 + 1 + 1 + 1 + 4 + 13 + 13 + 8 + 7 = ~49 base + more = ~60\nexport const FEATURE_VECTOR_LENGTH = 60;\n\nexport interface AudioEngineState {\n  isInitialized: boolean;\n  isCapturing: boolean;\n  isPlaying: boolean;\n  hasPermission: boolean;\n  error: string | null;\n}\n\nexport interface AudioEngineCallbacks {\n  onStateChange?: (state: AudioEngineState) => void;\n  onCaptureComplete?: (result: AudioCaptureResult) => void;\n  onError?: (error: Error) => void;\n}\n\n// Web Audio API related types\nexport interface AudioContextState {\n  context: AudioContext | null;\n  analyser: AnalyserNode | null;\n  stream: MediaStream | null;\n}\n","/**\n * ChirpGenerator - Generates logarithmic sine sweep chirps for acoustic measurement\n *\n * Two modes:\n * - Audible: 200 Hz - 18 kHz (higher accuracy, clearly audible)\n * - Ultrasonic: 15 kHz - 20 kHz (less audible, may have reduced accuracy)\n */\n\nimport { ChirpConfig, ChirpMode, CHIRP_PRESETS } from './types';\n\n/**\n * Generate a logarithmic sine sweep (chirp) signal\n *\n * The frequency follows: f(t) = f_start * (f_end / f_start)^(t/T)\n * This provides constant energy per octave, which is ideal for room acoustics measurement.\n */\nexport function generateChirp(config: ChirpConfig): Float32Array {\n  const {\n    startFrequency,\n    endFrequency,\n    duration,\n    sampleRate,\n    fadeTime,\n  } = config;\n\n  const numSamples = Math.floor(duration * sampleRate);\n  const signal = new Float32Array(numSamples);\n\n  // Logarithmic sweep parameters\n  const k = Math.log(endFrequency / startFrequency);\n\n  for (let i = 0; i < numSamples; i++) {\n    const t = i / sampleRate;\n    const tNorm = t / duration; // Normalized time [0, 1]\n\n    // Instantaneous frequency: f(t) = f_start * e^(k * t/T)\n    // Phase is integral of frequency: phi(t) = 2*pi * f_start * T/k * (e^(k*t/T) - 1)\n    const phase =\n      (2 * Math.PI * startFrequency * duration) / k *\n      (Math.exp(k * tNorm) - 1);\n\n    signal[i] = Math.sin(phase);\n  }\n\n  // Apply fade in/out envelope to prevent clicks\n  applyFadeEnvelope(signal, sampleRate, fadeTime);\n\n  return signal;\n}\n\n/**\n * Apply a smooth fade-in and fade-out envelope to prevent clicks\n * Uses a raised cosine (Hann) envelope for smooth transitions\n */\nfunction applyFadeEnvelope(\n  signal: Float32Array,\n  sampleRate: number,\n  fadeTime: number\n): void {\n  const fadeSamples = Math.floor(fadeTime * sampleRate);\n\n  for (let i = 0; i < fadeSamples && i < signal.length; i++) {\n    // Raised cosine fade-in\n    const envelope = 0.5 * (1 - Math.cos((Math.PI * i) / fadeSamples));\n    signal[i] *= envelope;\n  }\n\n  for (let i = 0; i < fadeSamples && i < signal.length; i++) {\n    // Raised cosine fade-out\n    const idx = signal.length - 1 - i;\n    const envelope = 0.5 * (1 - Math.cos((Math.PI * i) / fadeSamples));\n    signal[idx] *= envelope;\n  }\n}\n\n/**\n * Generate a chirp using preset mode\n */\nexport function generateChirpPreset(\n  mode: ChirpMode,\n  sampleRate: number = 48000\n): Float32Array {\n  const preset = CHIRP_PRESETS[mode];\n  return generateChirp({\n    ...preset,\n    sampleRate,\n  });\n}\n\n/**\n * Get full chirp config for a preset mode\n */\nexport function getChirpConfig(\n  mode: ChirpMode,\n  sampleRate: number = 48000\n): ChirpConfig {\n  return {\n    ...CHIRP_PRESETS[mode],\n    sampleRate,\n  };\n}\n\n/**\n * Create an AudioBuffer from a chirp signal for Web Audio API playback\n */\nexport function createChirpBuffer(\n  context: AudioContext,\n  mode: ChirpMode\n): AudioBuffer {\n  const config = getChirpConfig(mode, context.sampleRate);\n  const signal = generateChirp(config);\n\n  const buffer = context.createBuffer(1, signal.length, context.sampleRate);\n  buffer.copyToChannel(new Float32Array(signal), 0);\n\n  return buffer;\n}\n\n/**\n * Play a chirp through the audio context\n * Returns a promise that resolves when playback completes\n */\nexport function playChirp(\n  context: AudioContext,\n  mode: ChirpMode,\n  volume: number = 0.8\n): Promise<Float32Array> {\n  return new Promise((resolve) => {\n    const buffer = createChirpBuffer(context, mode);\n    const source = context.createBufferSource();\n    const gainNode = context.createGain();\n\n    source.buffer = buffer;\n    gainNode.gain.value = volume;\n\n    source.connect(gainNode);\n    gainNode.connect(context.destination);\n\n    source.onended = () => {\n      // Return the chirp signal for deconvolution\n      const signal = new Float32Array(buffer.length);\n      buffer.copyFromChannel(signal, 0);\n      resolve(signal);\n    };\n\n    source.start();\n  });\n}\n\n/**\n * Generate inverse filter for the chirp (used in deconvolution)\n * The inverse filter has time-reversed amplitude envelope\n */\nexport function generateInverseFilter(\n  chirp: Float32Array,\n  config: ChirpConfig\n): Float32Array {\n  const { startFrequency, endFrequency, duration } = config;\n\n  // Time-reverse the chirp\n  const inverse = new Float32Array(chirp.length);\n  for (let i = 0; i < chirp.length; i++) {\n    inverse[i] = chirp[chirp.length - 1 - i];\n  }\n\n  // Apply amplitude modulation to compensate for sweep rate\n  // Higher frequencies are swept faster, so they need more gain\n  const k = Math.log(endFrequency / startFrequency);\n\n  for (let i = 0; i < inverse.length; i++) {\n    const t = i / config.sampleRate;\n    const tNorm = t / duration;\n\n    // Amplitude envelope: proportional to 1/f(t)\n    // This gives equal energy per octave after convolution\n    const freqRatio = Math.exp(k * (1 - tNorm));\n    inverse[i] *= 1 / Math.sqrt(freqRatio);\n  }\n\n  return inverse;\n}\n\n/**\n * Calculate the expected duration of the impulse response\n * based on typical room reverberation times\n */\nexport function estimateIRDuration(sampleRate: number): number {\n  // Most rooms have RT60 < 2 seconds\n  // We capture a bit more to be safe\n  return Math.floor(2.5 * sampleRate);\n}\n","/**\n * AudioCapture - Handles microphone access and audio recording\n *\n * Uses Web Audio API for precise timing and synchronization\n * with chirp playback for acoustic measurement.\n */\n\nimport {\n  ChirpMode,\n  CaptureConfig,\n  DEFAULT_CAPTURE_CONFIG,\n  AudioCaptureResult,\n} from './types';\nimport { getChirpConfig, playChirp } from './ChirpGenerator';\n\n// Singleton audio context to avoid creating multiple instances\nlet audioContext: AudioContext | null = null;\n\n/**\n * Get or create the audio context\n * Handles the suspended state that occurs before user interaction\n */\nexport async function getAudioContext(): Promise<AudioContext> {\n  if (!audioContext) {\n    audioContext = new AudioContext({ sampleRate: 48000 });\n  }\n\n  // Resume if suspended (required on iOS and some browsers)\n  if (audioContext.state === 'suspended') {\n    await audioContext.resume();\n  }\n\n  return audioContext;\n}\n\n/**\n * Close the audio context and release resources\n */\nexport function closeAudioContext(): void {\n  if (audioContext) {\n    audioContext.close();\n    audioContext = null;\n  }\n}\n\n/**\n * Request microphone permission\n * Returns the MediaStream if granted\n */\nexport async function requestMicrophonePermission(): Promise<MediaStream> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: {\n        echoCancellation: false,  // We want the raw audio with echoes\n        noiseSuppression: false,  // Don't suppress room noise\n        autoGainControl: false,   // Keep consistent gain\n        sampleRate: 48000,\n      },\n    });\n    return stream;\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.name === 'NotAllowedError') {\n        throw new Error('Microphone permission denied. Please allow microphone access to use this feature.');\n      } else if (error.name === 'NotFoundError') {\n        throw new Error('No microphone found. Please connect a microphone and try again.');\n      }\n    }\n    throw error;\n  }\n}\n\n/**\n * Check if microphone permission has been granted\n */\nexport async function hasMicrophonePermission(): Promise<boolean> {\n  try {\n    const result = await navigator.permissions.query({\n      name: 'microphone' as PermissionName,\n    });\n    return result.state === 'granted';\n  } catch {\n    // Permissions API not supported, try requesting access\n    try {\n      const stream = await requestMicrophonePermission();\n      stream.getTracks().forEach((track) => track.stop());\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Record audio from the microphone for a specified duration\n */\nexport async function recordAudio(\n  stream: MediaStream,\n  durationSeconds: number,\n  sampleRate: number\n): Promise<Float32Array> {\n  const context = await getAudioContext();\n  const source = context.createMediaStreamSource(stream);\n\n  // Create a buffer to store recorded samples\n  const bufferSize = Math.ceil(durationSeconds * sampleRate);\n  const recordedSamples = new Float32Array(bufferSize);\n  let samplesRecorded = 0;\n\n  // Use ScriptProcessorNode for recording (AudioWorklet would be better but more complex)\n  // Note: ScriptProcessorNode is deprecated but still widely supported\n  const processorBufferSize = 4096;\n  const processor = context.createScriptProcessor(processorBufferSize, 1, 1);\n\n  return new Promise((resolve) => {\n    const timeout = setTimeout(() => {\n      cleanup();\n      resolve(recordedSamples);\n    }, durationSeconds * 1000 + 100); // Small buffer for timing\n\n    processor.onaudioprocess = (event) => {\n      const inputData = event.inputBuffer.getChannelData(0);\n      const remaining = bufferSize - samplesRecorded;\n\n      if (remaining <= 0) {\n        cleanup();\n        resolve(recordedSamples);\n        return;\n      }\n\n      const samplesToWrite = Math.min(inputData.length, remaining);\n      recordedSamples.set(inputData.subarray(0, samplesToWrite), samplesRecorded);\n      samplesRecorded += samplesToWrite;\n    };\n\n    function cleanup() {\n      clearTimeout(timeout);\n      processor.disconnect();\n      source.disconnect();\n    }\n\n    source.connect(processor);\n    processor.connect(context.destination); // Required for processing to work\n  });\n}\n\n/**\n * Capture audio by playing a chirp and recording the room response\n * This is the main function for acoustic measurement\n */\nexport async function captureRoomResponse(\n  mode: ChirpMode,\n  config: CaptureConfig = DEFAULT_CAPTURE_CONFIG,\n  volume: number = 0.8\n): Promise<AudioCaptureResult> {\n  // Get audio context and ensure it's running\n  const context = await getAudioContext();\n\n  // Request microphone access\n  const stream = await requestMicrophonePermission();\n\n  try {\n    // Get chirp configuration\n    const chirpConfig = getChirpConfig(mode, context.sampleRate);\n\n    // Calculate capture duration\n    // Total = pre-delay + chirp duration + reverb tail\n    const chirpDuration = chirpConfig.duration;\n    const reverbTail = 1.5; // 1.5 seconds for reverb to decay\n    const totalDuration = config.preDelay + chirpDuration + reverbTail;\n\n    // Start recording\n    const recordingPromise = recordAudio(stream, totalDuration, context.sampleRate);\n\n    // Wait for pre-delay, then play chirp\n    await sleep(config.preDelay * 1000);\n    const chirpSignal = await playChirp(context, mode, volume);\n\n    // Wait for recording to complete\n    const captured = await recordingPromise;\n\n    return {\n      captured,\n      chirp: chirpSignal,\n      sampleRate: context.sampleRate,\n      config: chirpConfig,\n      timestamp: Date.now(),\n    };\n  } finally {\n    // Stop all tracks to release the microphone\n    stream.getTracks().forEach((track) => track.stop());\n  }\n}\n\n/**\n * Capture audio in passive mode (no chirp, just background noise)\n * Useful for ambient acoustic fingerprinting\n */\nexport async function capturePassive(\n  durationSeconds: number = 3\n): Promise<{ audio: Float32Array; sampleRate: number; timestamp: number }> {\n  const context = await getAudioContext();\n  const stream = await requestMicrophonePermission();\n\n  try {\n    const audio = await recordAudio(stream, durationSeconds, context.sampleRate);\n    return {\n      audio,\n      sampleRate: context.sampleRate,\n      timestamp: Date.now(),\n    };\n  } finally {\n    stream.getTracks().forEach((track) => track.stop());\n  }\n}\n\n/**\n * Get real-time audio level (for UI feedback)\n */\nexport async function createLevelMeter(\n  stream: MediaStream,\n  callback: (level: number) => void\n): Promise<() => void> {\n  const context = await getAudioContext();\n  const source = context.createMediaStreamSource(stream);\n  const analyser = context.createAnalyser();\n\n  analyser.fftSize = 256;\n  source.connect(analyser);\n\n  const dataArray = new Float32Array(analyser.fftSize);\n  let animationId: number;\n\n  function update() {\n    analyser.getFloatTimeDomainData(dataArray);\n\n    // Calculate RMS level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i] * dataArray[i];\n    }\n    const rms = Math.sqrt(sum / dataArray.length);\n\n    // Convert to a 0-1 range (approximate)\n    const level = Math.min(1, rms * 5);\n    callback(level);\n\n    animationId = requestAnimationFrame(update);\n  }\n\n  update();\n\n  // Return cleanup function\n  return () => {\n    cancelAnimationFrame(animationId);\n    source.disconnect();\n    analyser.disconnect();\n  };\n}\n\n/**\n * Helper: sleep for a specified duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","/**\n * DSP utilities for audio processing\n * Includes FFT, windowing, and signal processing helpers\n */\n\n/**\n * Compute the next power of 2 greater than or equal to n\n */\nexport function nextPowerOf2(n: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * Zero-pad an array to a specific length\n */\nexport function zeroPad(signal: Float32Array, length: number): Float32Array {\n  if (signal.length >= length) {\n    return signal.slice(0, length);\n  }\n  const padded = new Float32Array(length);\n  padded.set(signal);\n  return padded;\n}\n\n/**\n * Hann window function\n */\nexport function hannWindow(length: number): Float32Array {\n  const window = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (length - 1)));\n  }\n  return window;\n}\n\n/**\n * Hamming window function\n */\nexport function hammingWindow(length: number): Float32Array {\n  const window = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window[i] = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (length - 1));\n  }\n  return window;\n}\n\n/**\n * Apply a window function to a signal\n */\nexport function applyWindow(signal: Float32Array, window: Float32Array): Float32Array {\n  const result = new Float32Array(signal.length);\n  const windowLength = Math.min(signal.length, window.length);\n  for (let i = 0; i < windowLength; i++) {\n    result[i] = signal[i] * window[i];\n  }\n  return result;\n}\n\n/**\n * Complex number representation for FFT\n */\nexport interface Complex {\n  re: number;\n  im: number;\n}\n\n/**\n * Create a complex number\n */\nexport function complex(re: number, im: number = 0): Complex {\n  return { re, im };\n}\n\n/**\n * Complex multiplication\n */\nexport function complexMul(a: Complex, b: Complex): Complex {\n  return {\n    re: a.re * b.re - a.im * b.im,\n    im: a.re * b.im + a.im * b.re,\n  };\n}\n\n/**\n * Complex addition\n */\nexport function complexAdd(a: Complex, b: Complex): Complex {\n  return {\n    re: a.re + b.re,\n    im: a.im + b.im,\n  };\n}\n\n/**\n * Complex subtraction\n */\nexport function complexSub(a: Complex, b: Complex): Complex {\n  return {\n    re: a.re - b.re,\n    im: a.im - b.im,\n  };\n}\n\n/**\n * Complex conjugate\n */\nexport function complexConj(a: Complex): Complex {\n  return { re: a.re, im: -a.im };\n}\n\n/**\n * Complex magnitude squared\n */\nexport function complexMagSq(a: Complex): number {\n  return a.re * a.re + a.im * a.im;\n}\n\n/**\n * Complex magnitude\n */\nexport function complexMag(a: Complex): number {\n  return Math.sqrt(complexMagSq(a));\n}\n\n/**\n * Complex division\n */\nexport function complexDiv(a: Complex, b: Complex): Complex {\n  const denom = complexMagSq(b);\n  return {\n    re: (a.re * b.re + a.im * b.im) / denom,\n    im: (a.im * b.re - a.re * b.im) / denom,\n  };\n}\n\n/**\n * Cooley-Tukey FFT (radix-2)\n * Input length must be a power of 2\n */\nexport function fft(input: Complex[]): Complex[] {\n  const N = input.length;\n\n  if (N <= 1) {\n    return input.slice();\n  }\n\n  if ((N & (N - 1)) !== 0) {\n    throw new Error('FFT input length must be a power of 2');\n  }\n\n  // Bit-reversal permutation\n  const output = new Array<Complex>(N);\n  const bits = Math.log2(N);\n\n  for (let i = 0; i < N; i++) {\n    let reversed = 0;\n    for (let j = 0; j < bits; j++) {\n      reversed = (reversed << 1) | ((i >> j) & 1);\n    }\n    output[reversed] = { ...input[i] };\n  }\n\n  // Iterative FFT\n  for (let size = 2; size <= N; size *= 2) {\n    const halfSize = size / 2;\n    const angle = (-2 * Math.PI) / size;\n\n    for (let i = 0; i < N; i += size) {\n      for (let j = 0; j < halfSize; j++) {\n        const w: Complex = {\n          re: Math.cos(angle * j),\n          im: Math.sin(angle * j),\n        };\n\n        const even = output[i + j];\n        const odd = complexMul(w, output[i + j + halfSize]);\n\n        output[i + j] = complexAdd(even, odd);\n        output[i + j + halfSize] = complexSub(even, odd);\n      }\n    }\n  }\n\n  return output;\n}\n\n/**\n * Inverse FFT\n */\nexport function ifft(input: Complex[]): Complex[] {\n  const N = input.length;\n\n  // Conjugate input\n  const conjugated = input.map(complexConj);\n\n  // Forward FFT\n  const transformed = fft(conjugated);\n\n  // Conjugate and scale\n  return transformed.map((c) => ({\n    re: c.re / N,\n    im: -c.im / N,\n  }));\n}\n\n/**\n * Real-valued FFT (returns only positive frequencies)\n */\nexport function rfft(signal: Float32Array): Complex[] {\n  const N = nextPowerOf2(signal.length);\n  const padded = zeroPad(signal, N);\n\n  // Convert to complex\n  const complex: Complex[] = Array.from(padded, (re) => ({ re, im: 0 }));\n\n  return fft(complex);\n}\n\n/**\n * Inverse real FFT\n */\nexport function irfft(spectrum: Complex[]): Float32Array {\n  const result = ifft(spectrum);\n  return new Float32Array(result.map((c) => c.re));\n}\n\n/**\n * Compute power spectrum from FFT result\n */\nexport function powerSpectrum(fftResult: Complex[]): Float32Array {\n  const N = fftResult.length;\n  const power = new Float32Array(N / 2 + 1);\n\n  for (let i = 0; i <= N / 2; i++) {\n    power[i] = complexMagSq(fftResult[i]) / N;\n  }\n\n  return power;\n}\n\n/**\n * Convert linear amplitude to decibels\n */\nexport function linearToDb(value: number, reference: number = 1): number {\n  return 20 * Math.log10(Math.max(value, 1e-10) / reference);\n}\n\n/**\n * Convert decibels to linear amplitude\n */\nexport function dbToLinear(db: number): number {\n  return Math.pow(10, db / 20);\n}\n\n/**\n * Root mean square of a signal\n */\nexport function rms(signal: Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < signal.length; i++) {\n    sum += signal[i] * signal[i];\n  }\n  return Math.sqrt(sum / signal.length);\n}\n\n/**\n * Normalize a signal to have maximum absolute value of 1\n */\nexport function normalize(signal: Float32Array): Float32Array {\n  const max = Math.max(...signal.map(Math.abs));\n  if (max === 0) return signal;\n\n  const normalized = new Float32Array(signal.length);\n  for (let i = 0; i < signal.length; i++) {\n    normalized[i] = signal[i] / max;\n  }\n  return normalized;\n}\n\n/**\n * Generate mel filterbank\n */\nexport function melFilterbank(\n  numFilters: number,\n  fftSize: number,\n  sampleRate: number,\n  lowFreq: number = 0,\n  highFreq?: number\n): Float32Array[] {\n  highFreq = highFreq ?? sampleRate / 2;\n\n  // Convert Hz to mel\n  const hzToMel = (hz: number) => 2595 * Math.log10(1 + hz / 700);\n  const melToHz = (mel: number) => 700 * (Math.pow(10, mel / 2595) - 1);\n\n  const lowMel = hzToMel(lowFreq);\n  const highMel = hzToMel(highFreq);\n\n  // Create mel points\n  const melPoints = new Float32Array(numFilters + 2);\n  for (let i = 0; i < numFilters + 2; i++) {\n    melPoints[i] = lowMel + (i * (highMel - lowMel)) / (numFilters + 1);\n  }\n\n  // Convert back to Hz and then to FFT bins\n  const hzPoints = melPoints.map(melToHz);\n  const binPoints = hzPoints.map((hz) =>\n    Math.floor(((fftSize + 1) * hz) / sampleRate)\n  );\n\n  // Create filterbank\n  const filterbank: Float32Array[] = [];\n  const numBins = fftSize / 2 + 1;\n\n  for (let i = 0; i < numFilters; i++) {\n    const filter = new Float32Array(numBins);\n    const startBin = binPoints[i];\n    const centerBin = binPoints[i + 1];\n    const endBin = binPoints[i + 2];\n\n    // Rising edge\n    for (let j = startBin; j < centerBin; j++) {\n      filter[j] = (j - startBin) / (centerBin - startBin);\n    }\n\n    // Falling edge\n    for (let j = centerBin; j < endBin; j++) {\n      filter[j] = (endBin - j) / (endBin - centerBin);\n    }\n\n    filterbank.push(filter);\n  }\n\n  return filterbank;\n}\n\n/**\n * Apply DCT (Type-II) to compute cepstral coefficients\n */\nexport function dct(input: Float32Array, numCoeffs?: number): Float32Array {\n  const N = input.length;\n  numCoeffs = numCoeffs ?? N;\n  const output = new Float32Array(numCoeffs);\n\n  for (let k = 0; k < numCoeffs; k++) {\n    let sum = 0;\n    for (let n = 0; n < N; n++) {\n      sum += input[n] * Math.cos((Math.PI * k * (2 * n + 1)) / (2 * N));\n    }\n    output[k] = sum * Math.sqrt(2 / N);\n  }\n\n  // Normalize first coefficient\n  output[0] *= Math.SQRT1_2;\n\n  return output;\n}\n\n/**\n * Frame a signal into overlapping windows\n */\nexport function frameSignal(\n  signal: Float32Array,\n  frameSize: number,\n  hopSize: number\n): Float32Array[] {\n  const frames: Float32Array[] = [];\n  let start = 0;\n\n  while (start + frameSize <= signal.length) {\n    frames.push(signal.slice(start, start + frameSize));\n    start += hopSize;\n  }\n\n  return frames;\n}\n\n/**\n * Calculate the mean of an array\n */\nexport function mean(arr: Float32Array | number[]): number {\n  if (arr.length === 0) return 0;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum / arr.length;\n}\n\n/**\n * Calculate the variance of an array\n */\nexport function variance(arr: Float32Array | number[]): number {\n  if (arr.length === 0) return 0;\n  const m = mean(arr);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const diff = arr[i] - m;\n    sum += diff * diff;\n  }\n  return sum / arr.length;\n}\n\n/**\n * Calculate the standard deviation of an array\n */\nexport function std(arr: Float32Array | number[]): number {\n  return Math.sqrt(variance(arr));\n}\n","/**\n * ImpulseResponseExtractor - Extracts room impulse response via deconvolution\n *\n * Uses frequency-domain deconvolution to extract the room's impulse response\n * from the recorded chirp response.\n *\n * H(f) = Y(f) * conj(X(f)) / (|X(f)|² + ε)\n *\n * where:\n * - Y(f) is the FFT of the recorded signal\n * - X(f) is the FFT of the original chirp\n * - ε is a regularization term to prevent division by zero\n */\n\nimport { ImpulseResponse, AudioCaptureResult, ChirpConfig } from './types';\nimport {\n  rfft,\n  irfft,\n  Complex,\n  complexMul,\n  complexConj,\n  complexMagSq,\n  nextPowerOf2,\n  zeroPad,\n  normalize,\n} from './utils';\n\n// Regularization parameter for deconvolution\nconst REGULARIZATION_EPSILON = 0.001;\n\n/**\n * Extract the room impulse response from a captured chirp response\n */\nexport function extractImpulseResponse(\n  captureResult: AudioCaptureResult\n): ImpulseResponse {\n  const { captured, chirp, sampleRate, config } = captureResult;\n\n  // Perform deconvolution\n  const ir = deconvolve(captured, chirp, config, REGULARIZATION_EPSILON);\n\n  // Trim the IR to a reasonable length (remove noise tail)\n  const trimmedIR = trimImpulseResponse(ir, sampleRate);\n\n  return {\n    data: trimmedIR,\n    sampleRate,\n    duration: trimmedIR.length / sampleRate,\n  };\n}\n\n/**\n * Frequency-domain deconvolution\n *\n * Computes H(f) = Y(f) * conj(X(f)) / (|X(f)|² + ε)\n */\nfunction deconvolve(\n  recorded: Float32Array,\n  chirp: Float32Array,\n  _config: ChirpConfig,\n  epsilon: number\n): Float32Array {\n  // Determine FFT size (must be power of 2, at least as long as both signals combined)\n  const minLength = recorded.length + chirp.length - 1;\n  const fftSize = nextPowerOf2(minLength);\n\n  // Zero-pad both signals to FFT size\n  const recordedPadded = zeroPad(recorded, fftSize);\n  const chirpPadded = zeroPad(chirp, fftSize);\n\n  // Compute FFTs\n  const Y = rfft(recordedPadded); // Recorded signal spectrum\n  const X = rfft(chirpPadded);    // Chirp spectrum\n\n  // Compute regularized deconvolution: H = Y * conj(X) / (|X|² + ε)\n  const H: Complex[] = new Array(Y.length);\n\n  for (let i = 0; i < Y.length; i++) {\n    const xConj = complexConj(X[i]);\n    const numerator = complexMul(Y[i], xConj);\n    const denominator = complexMagSq(X[i]) + epsilon;\n\n    H[i] = {\n      re: numerator.re / denominator,\n      im: numerator.im / denominator,\n    };\n  }\n\n  // Inverse FFT to get impulse response\n  // We need to reconstruct the full spectrum for IFFT\n  const fullSpectrum: Complex[] = new Array(fftSize);\n  for (let i = 0; i < fftSize; i++) {\n    if (i < H.length) {\n      fullSpectrum[i] = H[i];\n    } else {\n      // Mirror for negative frequencies (conjugate symmetry)\n      const mirrorIdx = fftSize - i;\n      fullSpectrum[i] = complexConj(H[mirrorIdx]);\n    }\n  }\n\n  const ir = irfft(fullSpectrum);\n\n  // Normalize the impulse response\n  return normalize(ir);\n}\n\n/**\n * Trim the impulse response to remove the noise tail\n * Uses energy-based detection to find the end of significant content\n */\nfunction trimImpulseResponse(\n  ir: Float32Array,\n  sampleRate: number\n): Float32Array {\n  // Maximum IR length we care about (2.5 seconds should cover most rooms)\n  const maxLength = Math.floor(2.5 * sampleRate);\n\n  // Find the peak (direct sound)\n  let peakIdx = 0;\n  let peakVal = 0;\n  for (let i = 0; i < ir.length; i++) {\n    const absVal = Math.abs(ir[i]);\n    if (absVal > peakVal) {\n      peakVal = absVal;\n      peakIdx = i;\n    }\n  }\n\n  // Start from a bit before the peak to capture the direct sound\n  const startIdx = Math.max(0, peakIdx - Math.floor(0.001 * sampleRate));\n\n  // Find where the energy drops below threshold\n  const threshold = peakVal * 0.001; // -60 dB below peak\n  let endIdx = Math.min(ir.length, startIdx + maxLength);\n\n  // Use a sliding window to find where energy stays below threshold\n  const windowSize = Math.floor(0.05 * sampleRate); // 50ms window\n  for (let i = startIdx + windowSize; i < endIdx - windowSize; i++) {\n    let windowEnergy = 0;\n    for (let j = 0; j < windowSize; j++) {\n      windowEnergy += ir[i + j] * ir[i + j];\n    }\n    windowEnergy = Math.sqrt(windowEnergy / windowSize);\n\n    if (windowEnergy < threshold) {\n      endIdx = i + windowSize;\n      break;\n    }\n  }\n\n  // Ensure minimum length (at least 100ms)\n  const minLength = Math.floor(0.1 * sampleRate);\n  if (endIdx - startIdx < minLength) {\n    endIdx = Math.min(ir.length, startIdx + minLength);\n  }\n\n  return ir.slice(startIdx, endIdx);\n}\n\n/**\n * Compute the Schroeder integration curve (backward integration)\n * Used for RT60 and EDT calculations\n */\nexport function schroederIntegration(ir: Float32Array): Float32Array {\n  const length = ir.length;\n  const schroeder = new Float32Array(length);\n\n  // Compute squared IR\n  const squared = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    squared[i] = ir[i] * ir[i];\n  }\n\n  // Backward integration\n  let sum = 0;\n  for (let i = length - 1; i >= 0; i--) {\n    sum += squared[i];\n    schroeder[i] = sum;\n  }\n\n  // Normalize by total energy\n  const totalEnergy = schroeder[0];\n  if (totalEnergy > 0) {\n    for (let i = 0; i < length; i++) {\n      schroeder[i] /= totalEnergy;\n    }\n  }\n\n  return schroeder;\n}\n\n/**\n * Convert Schroeder curve to decibels\n */\nexport function schroederToDb(schroeder: Float32Array): Float32Array {\n  const db = new Float32Array(schroeder.length);\n  for (let i = 0; i < schroeder.length; i++) {\n    db[i] = 10 * Math.log10(Math.max(schroeder[i], 1e-10));\n  }\n  return db;\n}\n\n/**\n * Find the time in seconds where the Schroeder curve crosses a threshold (in dB)\n */\nexport function findDecayTime(\n  schroederDb: Float32Array,\n  sampleRate: number,\n  thresholdDb: number\n): number {\n  for (let i = 0; i < schroederDb.length; i++) {\n    if (schroederDb[i] < thresholdDb) {\n      return i / sampleRate;\n    }\n  }\n  return schroederDb.length / sampleRate;\n}\n\n/**\n * Estimate RT60 from the impulse response using Schroeder integration\n * RT60 is the time for sound to decay by 60 dB\n *\n * We actually measure T30 (decay from -5 dB to -35 dB) and extrapolate\n */\nexport function estimateRT60(ir: Float32Array, sampleRate: number): number {\n  const schroeder = schroederIntegration(ir);\n  const schroederDb = schroederToDb(schroeder);\n\n  // Find -5 dB and -35 dB crossing points\n  const t5 = findDecayTime(schroederDb, sampleRate, -5);\n  const t35 = findDecayTime(schroederDb, sampleRate, -35);\n\n  // Linear extrapolation to -60 dB\n  // RT60 = (t35 - t5) * 60 / 30 = 2 * (t35 - t5)\n  const rt60 = 2 * (t35 - t5);\n\n  // Clamp to reasonable values (0.1s to 5s)\n  return Math.max(0.1, Math.min(5, rt60));\n}\n\n/**\n * Estimate EDT (Early Decay Time) from the impulse response\n * EDT is measured from 0 dB to -10 dB\n */\nexport function estimateEDT(ir: Float32Array, sampleRate: number): number {\n  const schroeder = schroederIntegration(ir);\n  const schroederDb = schroederToDb(schroeder);\n\n  // Find -10 dB crossing point\n  const t10 = findDecayTime(schroederDb, sampleRate, -10);\n\n  // Extrapolate to -60 dB\n  const edt = t10 * 6;\n\n  // Clamp to reasonable values\n  return Math.max(0.05, Math.min(3, edt));\n}\n","/**\n * FeatureExtractor - Extracts acoustic features from impulse response\n *\n * Extracts a comprehensive feature vector (~60 values) including:\n * - RT60, EDT (reverberation characteristics)\n * - C50, C80 (clarity ratios)\n * - Spectral features (centroid, rolloff, flux, flatness)\n * - MFCC coefficients (mean and variance)\n * - Early reflection energy\n * - Octave band energy\n */\n\nimport { ImpulseResponse, FeatureVector, FEATURE_VECTOR_LENGTH } from './types';\nimport {\n  estimateRT60,\n  estimateEDT,\n} from './ImpulseResponseExtractor';\nimport {\n  rfft,\n  powerSpectrum,\n  hannWindow,\n  applyWindow,\n  frameSignal,\n  melFilterbank,\n  dct,\n  mean,\n  variance,\n  linearToDb,\n} from './utils';\n\n// MFCC configuration\nconst NUM_MFCC = 13;\nconst NUM_MEL_FILTERS = 26;\nconst FRAME_SIZE_MS = 25;\nconst FRAME_HOP_MS = 10;\n\n// Early reflection time bins (0-80ms in 10ms steps)\nconst EARLY_REFLECTION_BINS = 8;\nconst EARLY_REFLECTION_STEP_MS = 10;\n\n// Octave band center frequencies (Hz)\nconst OCTAVE_BANDS = [125, 250, 500, 1000, 2000, 4000, 8000];\n\n/**\n * Extract all features from an impulse response\n */\nexport function extractFeatures(ir: ImpulseResponse): FeatureVector {\n  const { data, sampleRate } = ir;\n\n  // Reverberation characteristics\n  const rt60 = estimateRT60(data, sampleRate);\n  const edt = estimateEDT(data, sampleRate);\n\n  // Clarity ratios\n  const c50 = computeClarityRatio(data, sampleRate, 0.05);\n  const c80 = computeClarityRatio(data, sampleRate, 0.08);\n\n  // Spectral features\n  const spectralFeatures = computeSpectralFeatures(data, sampleRate);\n\n  // MFCC features\n  const { mfccMean, mfccVariance } = computeMFCCFeatures(data, sampleRate);\n\n  // Early reflection energy\n  const earlyReflections = computeEarlyReflectionEnergy(data, sampleRate);\n\n  // Octave band energy\n  const octaveBands = computeOctaveBandEnergy(data, sampleRate);\n\n  // Compile raw feature vector\n  const raw = compileFeatureVector({\n    rt60,\n    edt,\n    c50,\n    c80,\n    ...spectralFeatures,\n    mfccMean,\n    mfccVariance,\n    earlyReflections,\n    octaveBands,\n  });\n\n  return {\n    rt60,\n    edt,\n    c50,\n    c80,\n    ...spectralFeatures,\n    mfccMean,\n    mfccVariance,\n    earlyReflections,\n    octaveBands,\n    raw,\n  };\n}\n\n/**\n * Compute clarity ratio C(t) = 10 * log10(E_early / E_late)\n * where E_early is energy in first t seconds, E_late is remaining energy\n */\nfunction computeClarityRatio(\n  ir: Float32Array,\n  sampleRate: number,\n  timeSeconds: number\n): number {\n  const splitSample = Math.floor(timeSeconds * sampleRate);\n\n  let earlyEnergy = 0;\n  let lateEnergy = 0;\n\n  for (let i = 0; i < ir.length; i++) {\n    const energy = ir[i] * ir[i];\n    if (i < splitSample) {\n      earlyEnergy += energy;\n    } else {\n      lateEnergy += energy;\n    }\n  }\n\n  // Prevent division by zero\n  if (lateEnergy < 1e-10) {\n    return 20; // Maximum clarity (all energy is early)\n  }\n\n  return 10 * Math.log10(earlyEnergy / lateEnergy);\n}\n\n/**\n * Compute spectral features from the impulse response\n */\nfunction computeSpectralFeatures(\n  ir: Float32Array,\n  sampleRate: number\n): {\n  spectralCentroid: number;\n  spectralRolloff: number;\n  spectralFlux: number;\n  spectralFlatness: number;\n} {\n  // Compute spectrum\n  const spectrum = rfft(ir);\n  const power = powerSpectrum(spectrum);\n\n  // Frequency resolution\n  const freqResolution = sampleRate / (spectrum.length * 2);\n\n  // Spectral centroid: weighted mean of frequencies\n  let weightedSum = 0;\n  let totalPower = 0;\n  for (let i = 0; i < power.length; i++) {\n    const freq = i * freqResolution;\n    weightedSum += freq * power[i];\n    totalPower += power[i];\n  }\n  const spectralCentroid = totalPower > 0 ? weightedSum / totalPower : 0;\n\n  // Spectral rolloff: frequency below which 85% of power is contained\n  const rolloffThreshold = 0.85 * totalPower;\n  let cumulativePower = 0;\n  let spectralRolloff = 0;\n  for (let i = 0; i < power.length; i++) {\n    cumulativePower += power[i];\n    if (cumulativePower >= rolloffThreshold) {\n      spectralRolloff = i * freqResolution;\n      break;\n    }\n  }\n\n  // Spectral flux: L2 norm of spectrum (simplified single-frame version)\n  let flux = 0;\n  for (let i = 0; i < power.length; i++) {\n    flux += power[i];\n  }\n  const spectralFlux = Math.sqrt(flux);\n\n  // Spectral flatness: geometric mean / arithmetic mean\n  // Indicates how noise-like (flat) vs tonal the signal is\n  let logSum = 0;\n  let linearSum = 0;\n  let validBins = 0;\n  for (let i = 1; i < power.length; i++) {\n    if (power[i] > 1e-10) {\n      logSum += Math.log(power[i]);\n      linearSum += power[i];\n      validBins++;\n    }\n  }\n  const geometricMean = validBins > 0 ? Math.exp(logSum / validBins) : 0;\n  const arithmeticMean = validBins > 0 ? linearSum / validBins : 0;\n  const spectralFlatness = arithmeticMean > 0 ? geometricMean / arithmeticMean : 0;\n\n  return {\n    spectralCentroid,\n    spectralRolloff,\n    spectralFlux,\n    spectralFlatness,\n  };\n}\n\n/**\n * Compute MFCC features (mean and variance across frames)\n */\nfunction computeMFCCFeatures(\n  ir: Float32Array,\n  sampleRate: number\n): {\n  mfccMean: number[];\n  mfccVariance: number[];\n} {\n  const frameSize = Math.floor((FRAME_SIZE_MS / 1000) * sampleRate);\n  const hopSize = Math.floor((FRAME_HOP_MS / 1000) * sampleRate);\n\n  // Frame the signal\n  const frames = frameSignal(ir, frameSize, hopSize);\n\n  if (frames.length === 0) {\n    // Return zeros if signal too short\n    return {\n      mfccMean: new Array(NUM_MFCC).fill(0),\n      mfccVariance: new Array(NUM_MFCC).fill(0),\n    };\n  }\n\n  // Create window and mel filterbank\n  const window = hannWindow(frameSize);\n  const filterbank = melFilterbank(NUM_MEL_FILTERS, frameSize, sampleRate, 0, sampleRate / 2);\n\n  // Compute MFCCs for each frame\n  const allMfccs: number[][] = [];\n\n  for (const frame of frames) {\n    // Apply window\n    const windowed = applyWindow(frame, window);\n\n    // Compute power spectrum\n    const spectrum = rfft(windowed);\n    const power = powerSpectrum(spectrum);\n\n    // Apply mel filterbank\n    const melEnergies = new Float32Array(NUM_MEL_FILTERS);\n    for (let i = 0; i < NUM_MEL_FILTERS; i++) {\n      let energy = 0;\n      for (let j = 0; j < Math.min(power.length, filterbank[i].length); j++) {\n        energy += power[j] * filterbank[i][j];\n      }\n      melEnergies[i] = Math.log(Math.max(energy, 1e-10));\n    }\n\n    // Apply DCT to get MFCCs\n    const mfccs = dct(melEnergies, NUM_MFCC);\n    allMfccs.push(Array.from(mfccs));\n  }\n\n  // Compute mean and variance across frames\n  const mfccMean: number[] = [];\n  const mfccVariance: number[] = [];\n\n  for (let i = 0; i < NUM_MFCC; i++) {\n    const values = allMfccs.map((frame) => frame[i]);\n    mfccMean.push(mean(values));\n    mfccVariance.push(variance(values));\n  }\n\n  return { mfccMean, mfccVariance };\n}\n\n/**\n * Compute early reflection energy in time bins\n */\nfunction computeEarlyReflectionEnergy(\n  ir: Float32Array,\n  sampleRate: number\n): number[] {\n  const energies: number[] = [];\n  const binSamples = Math.floor((EARLY_REFLECTION_STEP_MS / 1000) * sampleRate);\n\n  for (let bin = 0; bin < EARLY_REFLECTION_BINS; bin++) {\n    const start = bin * binSamples;\n    const end = Math.min((bin + 1) * binSamples, ir.length);\n\n    let energy = 0;\n    for (let i = start; i < end; i++) {\n      energy += ir[i] * ir[i];\n    }\n\n    // Convert to dB (relative to first bin)\n    energies.push(energy);\n  }\n\n  // Normalize relative to first bin\n  const refEnergy = Math.max(energies[0], 1e-10);\n  return energies.map((e) => linearToDb(Math.sqrt(e / refEnergy)));\n}\n\n/**\n * Compute octave band energy\n */\nfunction computeOctaveBandEnergy(\n  ir: Float32Array,\n  sampleRate: number\n): number[] {\n  const spectrum = rfft(ir);\n  const power = powerSpectrum(spectrum);\n  const freqResolution = sampleRate / (spectrum.length * 2);\n\n  const energies: number[] = [];\n\n  for (const centerFreq of OCTAVE_BANDS) {\n    // Octave band spans from centerFreq/sqrt(2) to centerFreq*sqrt(2)\n    const lowFreq = centerFreq / Math.SQRT2;\n    const highFreq = centerFreq * Math.SQRT2;\n\n    const lowBin = Math.floor(lowFreq / freqResolution);\n    const highBin = Math.min(Math.ceil(highFreq / freqResolution), power.length - 1);\n\n    let energy = 0;\n    for (let i = lowBin; i <= highBin; i++) {\n      energy += power[i];\n    }\n\n    energies.push(energy);\n  }\n\n  // Normalize and convert to dB\n  const totalEnergy = energies.reduce((a, b) => a + b, 0);\n  if (totalEnergy > 0) {\n    return energies.map((e) => linearToDb(Math.sqrt(e / totalEnergy)));\n  }\n\n  return energies.map(() => -60); // Minimum dB if no energy\n}\n\n/**\n * Compile all features into a single vector for ML input\n */\nfunction compileFeatureVector(features: Omit<FeatureVector, 'raw'>): number[] {\n  const vector: number[] = [];\n\n  // Reverberation (2)\n  vector.push(features.rt60);\n  vector.push(features.edt);\n\n  // Clarity (2)\n  vector.push(features.c50);\n  vector.push(features.c80);\n\n  // Spectral (4)\n  vector.push(features.spectralCentroid / 10000); // Normalize to ~0-1 range\n  vector.push(features.spectralRolloff / 20000);  // Normalize to ~0-1 range\n  vector.push(features.spectralFlux);\n  vector.push(features.spectralFlatness);\n\n  // MFCC mean (13)\n  vector.push(...features.mfccMean);\n\n  // MFCC variance (13)\n  vector.push(...features.mfccVariance);\n\n  // Early reflections (8)\n  vector.push(...features.earlyReflections);\n\n  // Octave bands (7)\n  vector.push(...features.octaveBands);\n\n  // Pad to fixed length if needed\n  while (vector.length < FEATURE_VECTOR_LENGTH) {\n    vector.push(0);\n  }\n\n  return vector.slice(0, FEATURE_VECTOR_LENGTH);\n}\n\n/**\n * Extract features directly from captured audio result\n * Convenience function that combines IR extraction and feature extraction\n */\nexport function extractFeaturesFromCapture(\n  captured: Float32Array,\n  chirp: Float32Array,\n  sampleRate: number\n): FeatureVector {\n  // Import here to avoid circular dependency\n  const { extractImpulseResponse } = require('./ImpulseResponseExtractor');\n\n  const ir = extractImpulseResponse({\n    captured,\n    chirp,\n    sampleRate,\n    config: {\n      mode: 'audible',\n      startFrequency: 200,\n      endFrequency: 18000,\n      duration: 0.5,\n      sampleRate,\n      fadeTime: 0.01,\n    },\n    timestamp: Date.now(),\n  });\n\n  return extractFeatures(ir);\n}\n","/**\n * useAudioEngine - React hook for audio capture and feature extraction\n *\n * Provides:\n * - Microphone permission handling\n * - Chirp playback and audio capture\n * - Feature extraction from captured audio\n * - Real-time audio level monitoring\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport {\n  ChirpMode,\n  AudioCaptureResult,\n  FeatureVector,\n  captureRoomResponse,\n  hasMicrophonePermission,\n  requestMicrophonePermission,\n  closeAudioContext,\n  createLevelMeter,\n} from '../audio';\nimport { extractImpulseResponse } from '../audio/ImpulseResponseExtractor';\nimport { extractFeatures } from '../audio/FeatureExtractor';\n\nexport type CaptureState = 'idle' | 'requesting' | 'capturing' | 'processing' | 'complete' | 'error';\n\nexport interface AudioEngineState {\n  captureState: CaptureState;\n  hasPermission: boolean | null;\n  error: string | null;\n  audioLevel: number;\n  lastCapture: AudioCaptureResult | null;\n  lastFeatures: FeatureVector | null;\n}\n\nexport interface UseAudioEngineReturn {\n  state: AudioEngineState;\n  capture: (mode: ChirpMode) => Promise<FeatureVector | null>;\n  requestPermission: () => Promise<boolean>;\n  startLevelMonitor: () => Promise<() => void>;\n  reset: () => void;\n}\n\nexport function useAudioEngine(): UseAudioEngineReturn {\n  const [state, setState] = useState<AudioEngineState>({\n    captureState: 'idle',\n    hasPermission: null,\n    error: null,\n    audioLevel: 0,\n    lastCapture: null,\n    lastFeatures: null,\n  });\n\n  const levelMonitorCleanup = useRef<(() => void) | null>(null);\n\n  // Check permission on mount\n  useEffect(() => {\n    hasMicrophonePermission().then((hasPermission) => {\n      setState((prev) => ({ ...prev, hasPermission }));\n    });\n\n    // Cleanup on unmount\n    return () => {\n      if (levelMonitorCleanup.current) {\n        levelMonitorCleanup.current();\n      }\n      closeAudioContext();\n    };\n  }, []);\n\n  /**\n   * Request microphone permission\n   */\n  const requestPermission = useCallback(async (): Promise<boolean> => {\n    setState((prev) => ({ ...prev, captureState: 'requesting', error: null }));\n\n    try {\n      const stream = await requestMicrophonePermission();\n      // Stop the stream immediately - we just wanted permission\n      stream.getTracks().forEach((track) => track.stop());\n\n      setState((prev) => ({\n        ...prev,\n        captureState: 'idle',\n        hasPermission: true,\n      }));\n      return true;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Permission denied';\n      setState((prev) => ({\n        ...prev,\n        captureState: 'error',\n        hasPermission: false,\n        error: message,\n      }));\n      return false;\n    }\n  }, []);\n\n  /**\n   * Capture audio and extract features\n   */\n  const capture = useCallback(async (mode: ChirpMode): Promise<FeatureVector | null> => {\n    setState((prev) => ({\n      ...prev,\n      captureState: 'capturing',\n      error: null,\n      lastCapture: null,\n      lastFeatures: null,\n    }));\n\n    try {\n      // Capture room response\n      const captureResult = await captureRoomResponse(mode);\n\n      setState((prev) => ({\n        ...prev,\n        captureState: 'processing',\n        lastCapture: captureResult,\n      }));\n\n      // Extract impulse response\n      const ir = extractImpulseResponse(captureResult);\n\n      // Extract features\n      const features = extractFeatures(ir);\n\n      setState((prev) => ({\n        ...prev,\n        captureState: 'complete',\n        lastFeatures: features,\n      }));\n\n      return features;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Capture failed';\n      setState((prev) => ({\n        ...prev,\n        captureState: 'error',\n        error: message,\n      }));\n      return null;\n    }\n  }, []);\n\n  /**\n   * Start real-time audio level monitoring\n   * Returns a cleanup function\n   */\n  const startLevelMonitor = useCallback(async (): Promise<() => void> => {\n    // Stop existing monitor\n    if (levelMonitorCleanup.current) {\n      levelMonitorCleanup.current();\n    }\n\n    try {\n      const stream = await requestMicrophonePermission();\n\n      const cleanup = await createLevelMeter(stream, (level) => {\n        setState((prev) => ({ ...prev, audioLevel: level }));\n      });\n\n      // Wrap cleanup to also stop the stream\n      const fullCleanup = () => {\n        cleanup();\n        stream.getTracks().forEach((track) => track.stop());\n        setState((prev) => ({ ...prev, audioLevel: 0 }));\n      };\n\n      levelMonitorCleanup.current = fullCleanup;\n      return fullCleanup;\n    } catch (error) {\n      console.error('Failed to start level monitor:', error);\n      return () => {};\n    }\n  }, []);\n\n  /**\n   * Reset state\n   */\n  const reset = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      captureState: 'idle',\n      error: null,\n      lastCapture: null,\n      lastFeatures: null,\n    }));\n  }, []);\n\n  return {\n    state,\n    capture,\n    requestPermission,\n    startLevelMonitor,\n    reset,\n  };\n}\n"],"names":["CHIRP_PRESETS","DEFAULT_CAPTURE_CONFIG","FEATURE_VECTOR_LENGTH","generateChirp","config","startFrequency","endFrequency","duration","sampleRate","fadeTime","numSamples","signal","k","i","tNorm","phase","applyFadeEnvelope","fadeSamples","envelope","idx","getChirpConfig","mode","createChirpBuffer","context","buffer","playChirp","volume","resolve","source","gainNode","audioContext","getAudioContext","closeAudioContext","requestMicrophonePermission","error","hasMicrophonePermission","track","recordAudio","stream","durationSeconds","bufferSize","recordedSamples","samplesRecorded","processor","timeout","cleanup","event","inputData","remaining","samplesToWrite","captureRoomResponse","chirpConfig","chirpDuration","totalDuration","recordingPromise","sleep","chirpSignal","createLevelMeter","callback","analyser","dataArray","animationId","update","sum","rms","level","ms","nextPowerOf2","n","zeroPad","length","padded","hannWindow","window","applyWindow","result","windowLength","complexMul","a","b","complexAdd","complexSub","complexConj","complexMagSq","fft","input","N","output","bits","reversed","j","size","halfSize","angle","w","even","odd","ifft","conjugated","c","rfft","complex","re","irfft","spectrum","powerSpectrum","fftResult","power","linearToDb","value","reference","normalize","max","normalized","melFilterbank","numFilters","fftSize","lowFreq","highFreq","hzToMel","hz","melToHz","mel","lowMel","highMel","melPoints","binPoints","filterbank","numBins","filter","startBin","centerBin","endBin","dct","numCoeffs","frameSignal","frameSize","hopSize","frames","start","mean","arr","variance","m","diff","REGULARIZATION_EPSILON","extractImpulseResponse","captureResult","captured","chirp","ir","deconvolve","trimmedIR","trimImpulseResponse","recorded","_config","epsilon","minLength","recordedPadded","chirpPadded","Y","X","H","xConj","numerator","denominator","fullSpectrum","mirrorIdx","maxLength","peakIdx","peakVal","absVal","startIdx","threshold","endIdx","windowSize","windowEnergy","schroederIntegration","schroeder","squared","totalEnergy","schroederToDb","db","findDecayTime","schroederDb","thresholdDb","estimateRT60","t5","rt60","estimateEDT","edt","NUM_MFCC","NUM_MEL_FILTERS","FRAME_SIZE_MS","FRAME_HOP_MS","EARLY_REFLECTION_BINS","EARLY_REFLECTION_STEP_MS","OCTAVE_BANDS","extractFeatures","data","c50","computeClarityRatio","c80","spectralFeatures","computeSpectralFeatures","mfccMean","mfccVariance","computeMFCCFeatures","earlyReflections","computeEarlyReflectionEnergy","octaveBands","computeOctaveBandEnergy","raw","compileFeatureVector","timeSeconds","splitSample","earlyEnergy","lateEnergy","energy","freqResolution","weightedSum","totalPower","freq","spectralCentroid","rolloffThreshold","cumulativePower","spectralRolloff","flux","spectralFlux","logSum","linearSum","validBins","geometricMean","arithmeticMean","spectralFlatness","allMfccs","frame","windowed","melEnergies","mfccs","values","energies","binSamples","bin","end","refEnergy","e","centerFreq","lowBin","highBin","features","vector","useAudioEngine","state","setState","useState","levelMonitorCleanup","useRef","useEffect","hasPermission","prev","requestPermission","useCallback","message","capture","startLevelMonitor","fullCleanup","reset"],"mappings":"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"}