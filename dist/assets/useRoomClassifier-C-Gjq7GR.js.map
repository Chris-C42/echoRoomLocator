{"version":3,"file":"useRoomClassifier-C-Gjq7GR.js","sources":["../../node_modules/idb/build/wrap-idb-value.js","../../node_modules/idb/build/index.js","../../src/storage/types.ts","../../src/storage/database.ts","../../node_modules/uuid/dist/esm-browser/rng.js","../../node_modules/uuid/dist/esm-browser/stringify.js","../../node_modules/uuid/dist/esm-browser/native.js","../../node_modules/uuid/dist/esm-browser/v4.js","../../src/storage/RoomStore.ts","../../src/storage/SampleStore.ts","../../src/storage/ModelStore.ts","../../src/hooks/useRooms.ts","../../src/ml/types.ts","../../src/ml/FeatureNormalizer.ts","../../src/ml/ConfidenceEstimator.ts","../../src/ml/RoomClassifier.ts","../../src/ml/ModelTrainer.ts","../../src/hooks/useRoomClassifier.ts"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","/**\n * Storage type definitions for EchoRoom\n */\n\nexport interface Room {\n  id: string;\n  name: string;\n  icon?: string;       // Emoji or icon name\n  color?: string;      // Hex color for UI\n  createdAt: number;   // Unix timestamp\n  updatedAt: number;   // Unix timestamp\n}\n\nexport interface Sample {\n  id: string;\n  roomId: string;      // Foreign key to Room\n  features: number[];  // Feature vector (~60 values)\n  metadata: SampleMetadata;\n  capturedAt: number;  // Unix timestamp\n}\n\nexport interface SampleMetadata {\n  chirpMode: 'audible' | 'ultrasonic';\n  duration: number;    // Chirp duration in ms\n  sampleRate: number;  // Audio sample rate\n  deviceInfo?: string; // Optional device identifier\n}\n\nexport interface StoredModel {\n  id: 'current';       // Fixed key - only one model at a time\n  topology: object;    // TensorFlow.js model JSON\n  weights: ArrayBuffer; // Serialized model weights\n  roomLabels: string[]; // Room ID to class index mapping\n  normalizer: FeatureNormalizer;\n  metadata: ModelMetadata;\n  createdAt: number;\n}\n\nexport interface FeatureNormalizer {\n  mean: number[];      // Mean for each feature\n  std: number[];       // Standard deviation for each feature\n  featureCount: number; // Number of features\n}\n\nexport interface ModelMetadata {\n  accuracy: number;    // Final validation accuracy\n  loss: number;        // Final validation loss\n  epochs: number;      // Number of epochs trained\n  samplesUsed: number; // Total samples used for training\n  roomCount: number;   // Number of rooms in model\n}\n\nexport interface TrainingProgress {\n  epoch: number;\n  totalEpochs: number;\n  loss: number;\n  accuracy: number;\n  valLoss?: number;\n  valAccuracy?: number;\n}\n\n// Database schema version for migrations\nexport const DB_VERSION = 1;\nexport const DB_NAME = 'echoroom-db';\n\n// Store names\nexport const STORES = {\n  ROOMS: 'rooms',\n  SAMPLES: 'samples',\n  MODEL: 'model',\n} as const;\n","/**\n * IndexedDB database setup and initialization\n */\n\nimport { openDB, DBSchema, IDBPDatabase } from 'idb';\nimport { Room, Sample, StoredModel, DB_NAME, DB_VERSION, STORES } from './types';\n\ninterface EchoRoomDB extends DBSchema {\n  [STORES.ROOMS]: {\n    key: string;\n    value: Room;\n    indexes: {\n      'by-name': string;\n      'by-created': number;\n    };\n  };\n  [STORES.SAMPLES]: {\n    key: string;\n    value: Sample;\n    indexes: {\n      'by-room': string;\n      'by-captured': number;\n    };\n  };\n  [STORES.MODEL]: {\n    key: 'current';\n    value: StoredModel;\n  };\n}\n\nlet dbInstance: IDBPDatabase<EchoRoomDB> | null = null;\n\n/**\n * Get or create the database instance\n */\nexport async function getDatabase(): Promise<IDBPDatabase<EchoRoomDB>> {\n  if (dbInstance) {\n    return dbInstance;\n  }\n\n  dbInstance = await openDB<EchoRoomDB>(DB_NAME, DB_VERSION, {\n    upgrade(db, oldVersion, newVersion, _transaction) {\n      console.log(`Upgrading database from v${oldVersion} to v${newVersion}`);\n\n      // Create rooms store\n      if (!db.objectStoreNames.contains(STORES.ROOMS)) {\n        const roomStore = db.createObjectStore(STORES.ROOMS, { keyPath: 'id' });\n        roomStore.createIndex('by-name', 'name');\n        roomStore.createIndex('by-created', 'createdAt');\n      }\n\n      // Create samples store\n      if (!db.objectStoreNames.contains(STORES.SAMPLES)) {\n        const sampleStore = db.createObjectStore(STORES.SAMPLES, { keyPath: 'id' });\n        sampleStore.createIndex('by-room', 'roomId');\n        sampleStore.createIndex('by-captured', 'capturedAt');\n      }\n\n      // Create model store\n      if (!db.objectStoreNames.contains(STORES.MODEL)) {\n        db.createObjectStore(STORES.MODEL, { keyPath: 'id' });\n      }\n    },\n    blocked() {\n      console.warn('Database upgrade blocked - close other tabs');\n    },\n    blocking() {\n      // Close our connection to allow upgrade in other tab\n      dbInstance?.close();\n      dbInstance = null;\n    },\n    terminated() {\n      console.error('Database connection terminated unexpectedly');\n      dbInstance = null;\n    },\n  });\n\n  return dbInstance;\n}\n\n/**\n * Close the database connection\n */\nexport function closeDatabase(): void {\n  if (dbInstance) {\n    dbInstance.close();\n    dbInstance = null;\n  }\n}\n\n/**\n * Delete the entire database (use with caution)\n */\nexport async function deleteDatabase(): Promise<void> {\n  closeDatabase();\n  await indexedDB.deleteDatabase(DB_NAME);\n}\n\n/**\n * Check if the database is available and working\n */\nexport async function isDatabaseAvailable(): Promise<boolean> {\n  try {\n    const db = await getDatabase();\n    return db !== null;\n  } catch (error) {\n    console.error('Database not available:', error);\n    return false;\n  }\n}\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","/**\n * Room storage operations\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { getDatabase } from './database';\nimport { Room, STORES } from './types';\n\n/**\n * Create a new room\n */\nexport async function createRoom(\n  name: string,\n  options?: { icon?: string; color?: string }\n): Promise<Room> {\n  const db = await getDatabase();\n\n  const room: Room = {\n    id: uuidv4(),\n    name: name.trim(),\n    icon: options?.icon,\n    color: options?.color,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  };\n\n  await db.add(STORES.ROOMS, room);\n  return room;\n}\n\n/**\n * Get a room by ID\n */\nexport async function getRoom(id: string): Promise<Room | undefined> {\n  const db = await getDatabase();\n  return db.get(STORES.ROOMS, id);\n}\n\n/**\n * Get all rooms\n */\nexport async function getAllRooms(): Promise<Room[]> {\n  const db = await getDatabase();\n  return db.getAll(STORES.ROOMS);\n}\n\n/**\n * Get all rooms sorted by creation date (newest first)\n */\nexport async function getRoomsByCreated(): Promise<Room[]> {\n  const db = await getDatabase();\n  const rooms = await db.getAllFromIndex(STORES.ROOMS, 'by-created');\n  return rooms.reverse(); // Newest first\n}\n\n/**\n * Update a room\n */\nexport async function updateRoom(\n  id: string,\n  updates: Partial<Omit<Room, 'id' | 'createdAt'>>\n): Promise<Room | undefined> {\n  const db = await getDatabase();\n\n  const existing = await db.get(STORES.ROOMS, id);\n  if (!existing) {\n    return undefined;\n  }\n\n  const updated: Room = {\n    ...existing,\n    ...updates,\n    updatedAt: Date.now(),\n  };\n\n  await db.put(STORES.ROOMS, updated);\n  return updated;\n}\n\n/**\n * Delete a room and all its samples\n */\nexport async function deleteRoom(id: string): Promise<boolean> {\n  const db = await getDatabase();\n\n  // Start a transaction for both stores\n  const tx = db.transaction([STORES.ROOMS, STORES.SAMPLES], 'readwrite');\n\n  // Delete all samples for this room\n  const sampleStore = tx.objectStore(STORES.SAMPLES);\n  const sampleIndex = sampleStore.index('by-room');\n  let cursor = await sampleIndex.openCursor(IDBKeyRange.only(id));\n\n  while (cursor) {\n    await cursor.delete();\n    cursor = await cursor.continue();\n  }\n\n  // Delete the room\n  await tx.objectStore(STORES.ROOMS).delete(id);\n  await tx.done;\n\n  return true;\n}\n\n/**\n * Get the count of rooms\n */\nexport async function getRoomCount(): Promise<number> {\n  const db = await getDatabase();\n  return db.count(STORES.ROOMS);\n}\n\n/**\n * Check if a room name already exists\n */\nexport async function roomNameExists(name: string): Promise<boolean> {\n  const db = await getDatabase();\n  const room = await db.getFromIndex(STORES.ROOMS, 'by-name', name.trim());\n  return room !== undefined;\n}\n","/**\n * Sample storage operations\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { getDatabase } from './database';\nimport { Sample, SampleMetadata, STORES } from './types';\n\n/**\n * Create a new sample for a room\n */\nexport async function createSample(\n  roomId: string,\n  features: number[],\n  metadata: SampleMetadata\n): Promise<Sample> {\n  const db = await getDatabase();\n\n  const sample: Sample = {\n    id: uuidv4(),\n    roomId,\n    features,\n    metadata,\n    capturedAt: Date.now(),\n  };\n\n  await db.add(STORES.SAMPLES, sample);\n  return sample;\n}\n\n/**\n * Get a sample by ID\n */\nexport async function getSample(id: string): Promise<Sample | undefined> {\n  const db = await getDatabase();\n  return db.get(STORES.SAMPLES, id);\n}\n\n/**\n * Get all samples for a specific room\n */\nexport async function getSamplesForRoom(roomId: string): Promise<Sample[]> {\n  const db = await getDatabase();\n  return db.getAllFromIndex(STORES.SAMPLES, 'by-room', roomId);\n}\n\n/**\n * Get all samples\n */\nexport async function getAllSamples(): Promise<Sample[]> {\n  const db = await getDatabase();\n  return db.getAll(STORES.SAMPLES);\n}\n\n/**\n * Get sample count for a specific room\n */\nexport async function getSampleCountForRoom(roomId: string): Promise<number> {\n  const db = await getDatabase();\n  const samples = await db.getAllKeysFromIndex(STORES.SAMPLES, 'by-room', roomId);\n  return samples.length;\n}\n\n/**\n * Get sample counts for all rooms\n */\nexport async function getSampleCountsByRoom(): Promise<Map<string, number>> {\n  const db = await getDatabase();\n  const samples = await db.getAll(STORES.SAMPLES);\n\n  const counts = new Map<string, number>();\n  for (const sample of samples) {\n    const current = counts.get(sample.roomId) || 0;\n    counts.set(sample.roomId, current + 1);\n  }\n\n  return counts;\n}\n\n/**\n * Delete a sample\n */\nexport async function deleteSample(id: string): Promise<boolean> {\n  const db = await getDatabase();\n  await db.delete(STORES.SAMPLES, id);\n  return true;\n}\n\n/**\n * Delete all samples for a room\n */\nexport async function deleteSamplesForRoom(roomId: string): Promise<number> {\n  const db = await getDatabase();\n\n  const tx = db.transaction(STORES.SAMPLES, 'readwrite');\n  const index = tx.store.index('by-room');\n  let cursor = await index.openCursor(IDBKeyRange.only(roomId));\n\n  let count = 0;\n  while (cursor) {\n    await cursor.delete();\n    count++;\n    cursor = await cursor.continue();\n  }\n\n  await tx.done;\n  return count;\n}\n\n/**\n * Get total sample count\n */\nexport async function getTotalSampleCount(): Promise<number> {\n  const db = await getDatabase();\n  return db.count(STORES.SAMPLES);\n}\n\n/**\n * Get training data: features and labels for all samples\n * Returns samples grouped by room with their feature vectors\n */\nexport async function getTrainingData(): Promise<{\n  features: number[][];\n  labels: string[];\n  roomIds: string[];\n}> {\n  const db = await getDatabase();\n  const samples = await db.getAll(STORES.SAMPLES);\n\n  const features: number[][] = [];\n  const labels: string[] = [];\n  const roomIdSet = new Set<string>();\n\n  for (const sample of samples) {\n    features.push(sample.features);\n    labels.push(sample.roomId);\n    roomIdSet.add(sample.roomId);\n  }\n\n  return {\n    features,\n    labels,\n    roomIds: Array.from(roomIdSet),\n  };\n}\n\n/**\n * Check if we have enough samples for training\n * Requires at least 2 rooms with minSamplesPerRoom samples each\n */\nexport async function canTrain(minSamplesPerRoom = 5): Promise<{\n  canTrain: boolean;\n  roomCount: number;\n  readyRooms: number;\n  totalSamples: number;\n  message: string;\n}> {\n  const counts = await getSampleCountsByRoom();\n  const roomCount = counts.size;\n\n  let readyRooms = 0;\n  let totalSamples = 0;\n\n  for (const count of counts.values()) {\n    totalSamples += count;\n    if (count >= minSamplesPerRoom) {\n      readyRooms++;\n    }\n  }\n\n  const canTrainResult = readyRooms >= 2;\n\n  let message: string;\n  if (roomCount < 2) {\n    message = `Need at least 2 rooms (have ${roomCount})`;\n  } else if (readyRooms < 2) {\n    message = `Need at least 2 rooms with ${minSamplesPerRoom}+ samples (have ${readyRooms})`;\n  } else {\n    message = `Ready to train with ${readyRooms} rooms and ${totalSamples} samples`;\n  }\n\n  return {\n    canTrain: canTrainResult,\n    roomCount,\n    readyRooms,\n    totalSamples,\n    message,\n  };\n}\n","/**\n * Model storage operations\n */\n\nimport { getDatabase } from './database';\nimport { StoredModel, FeatureNormalizer, ModelMetadata, STORES } from './types';\n\nconst MODEL_ID = 'current' as const;\n\n/**\n * Save a trained model\n */\nexport async function saveModel(\n  topology: object,\n  weights: ArrayBuffer,\n  roomLabels: string[],\n  normalizer: FeatureNormalizer,\n  metadata: ModelMetadata\n): Promise<StoredModel> {\n  const db = await getDatabase();\n\n  const storedModel: StoredModel = {\n    id: MODEL_ID,\n    topology,\n    weights,\n    roomLabels,\n    normalizer,\n    metadata,\n    createdAt: Date.now(),\n  };\n\n  await db.put(STORES.MODEL, storedModel);\n  return storedModel;\n}\n\n/**\n * Get the current stored model\n */\nexport async function getModel(): Promise<StoredModel | undefined> {\n  const db = await getDatabase();\n  return db.get(STORES.MODEL, MODEL_ID);\n}\n\n/**\n * Check if a model exists\n */\nexport async function hasModel(): Promise<boolean> {\n  const model = await getModel();\n  return model !== undefined;\n}\n\n/**\n * Delete the stored model\n */\nexport async function deleteModel(): Promise<boolean> {\n  const db = await getDatabase();\n\n  const existing = await db.get(STORES.MODEL, MODEL_ID);\n  if (!existing) {\n    return false;\n  }\n\n  await db.delete(STORES.MODEL, MODEL_ID);\n  return true;\n}\n\n/**\n * Get model metadata without loading the full weights\n */\nexport async function getModelMetadata(): Promise<{\n  roomLabels: string[];\n  normalizer: FeatureNormalizer;\n  metadata: ModelMetadata;\n  createdAt: number;\n} | undefined> {\n  const model = await getModel();\n  if (!model) {\n    return undefined;\n  }\n\n  return {\n    roomLabels: model.roomLabels,\n    normalizer: model.normalizer,\n    metadata: model.metadata,\n    createdAt: model.createdAt,\n  };\n}\n\n/**\n * Get room labels from the model (for inference)\n */\nexport async function getModelRoomLabels(): Promise<string[] | undefined> {\n  const model = await getModel();\n  return model?.roomLabels;\n}\n\n/**\n * Get the feature normalizer from the model\n */\nexport async function getModelNormalizer(): Promise<FeatureNormalizer | undefined> {\n  const model = await getModel();\n  return model?.normalizer;\n}\n\n/**\n * Check if the model needs retraining\n * (e.g., if rooms have been added/removed since training)\n */\nexport async function modelNeedsRetraining(currentRoomIds: string[]): Promise<boolean> {\n  const model = await getModel();\n  if (!model) {\n    return true; // No model = needs training\n  }\n\n  const modelRoomSet = new Set(model.roomLabels);\n  const currentRoomSet = new Set(currentRoomIds);\n\n  // Check if sets are different\n  if (modelRoomSet.size !== currentRoomSet.size) {\n    return true;\n  }\n\n  for (const roomId of currentRoomIds) {\n    if (!modelRoomSet.has(roomId)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/**\n * useRooms - React hook for room management\n *\n * Provides:\n * - Room CRUD operations\n * - Reactive state updates\n * - Sample counts per room\n */\n\nimport { useState, useCallback, useEffect } from 'react';\nimport {\n  Room,\n  createRoom,\n  getAllRooms,\n  getRoom,\n  updateRoom,\n  deleteRoom,\n  roomNameExists,\n  getSampleCountsByRoom,\n} from '../storage';\n\nexport interface RoomWithSampleCount extends Room {\n  sampleCount: number;\n}\n\nexport interface UseRoomsState {\n  rooms: RoomWithSampleCount[];\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface UseRoomsReturn {\n  state: UseRoomsState;\n  addRoom: (name: string, options?: { icon?: string; color?: string }) => Promise<Room | null>;\n  editRoom: (id: string, updates: { name?: string; icon?: string; color?: string }) => Promise<boolean>;\n  removeRoom: (id: string) => Promise<boolean>;\n  refreshRooms: () => Promise<void>;\n  getRoomById: (id: string) => RoomWithSampleCount | undefined;\n}\n\nexport function useRooms(): UseRoomsReturn {\n  const [state, setState] = useState<UseRoomsState>({\n    rooms: [],\n    isLoading: true,\n    error: null,\n  });\n\n  /**\n   * Load all rooms with sample counts\n   */\n  const refreshRooms = useCallback(async () => {\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      const [rooms, sampleCounts] = await Promise.all([\n        getAllRooms(),\n        getSampleCountsByRoom(),\n      ]);\n\n      const roomsWithCounts: RoomWithSampleCount[] = rooms.map((room) => ({\n        ...room,\n        sampleCount: sampleCounts.get(room.id) || 0,\n      }));\n\n      // Sort by creation date (newest first)\n      roomsWithCounts.sort((a, b) => b.createdAt - a.createdAt);\n\n      setState({\n        rooms: roomsWithCounts,\n        isLoading: false,\n        error: null,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to load rooms';\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        error: message,\n      }));\n    }\n  }, []);\n\n  // Load rooms on mount\n  useEffect(() => {\n    refreshRooms();\n  }, [refreshRooms]);\n\n  /**\n   * Add a new room\n   */\n  const addRoom = useCallback(async (\n    name: string,\n    options?: { icon?: string; color?: string }\n  ): Promise<Room | null> => {\n    try {\n      // Check if name already exists\n      const exists = await roomNameExists(name);\n      if (exists) {\n        setState((prev) => ({\n          ...prev,\n          error: `A room named \"${name}\" already exists`,\n        }));\n        return null;\n      }\n\n      const room = await createRoom(name, options);\n\n      // Update local state\n      setState((prev) => ({\n        ...prev,\n        rooms: [{ ...room, sampleCount: 0 }, ...prev.rooms],\n        error: null,\n      }));\n\n      return room;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to create room';\n      setState((prev) => ({ ...prev, error: message }));\n      return null;\n    }\n  }, []);\n\n  /**\n   * Edit an existing room\n   */\n  const editRoom = useCallback(async (\n    id: string,\n    updates: { name?: string; icon?: string; color?: string }\n  ): Promise<boolean> => {\n    try {\n      // Check if new name already exists (if name is being changed)\n      if (updates.name) {\n        const currentRoom = await getRoom(id);\n        if (currentRoom && currentRoom.name !== updates.name) {\n          const exists = await roomNameExists(updates.name);\n          if (exists) {\n            setState((prev) => ({\n              ...prev,\n              error: `A room named \"${updates.name}\" already exists`,\n            }));\n            return false;\n          }\n        }\n      }\n\n      const updated = await updateRoom(id, updates);\n      if (!updated) {\n        setState((prev) => ({ ...prev, error: 'Room not found' }));\n        return false;\n      }\n\n      // Update local state\n      setState((prev) => ({\n        ...prev,\n        rooms: prev.rooms.map((room) =>\n          room.id === id ? { ...room, ...updated } : room\n        ),\n        error: null,\n      }));\n\n      return true;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to update room';\n      setState((prev) => ({ ...prev, error: message }));\n      return false;\n    }\n  }, []);\n\n  /**\n   * Remove a room (and all its samples)\n   */\n  const removeRoom = useCallback(async (id: string): Promise<boolean> => {\n    try {\n      await deleteRoom(id);\n\n      // Update local state\n      setState((prev) => ({\n        ...prev,\n        rooms: prev.rooms.filter((room) => room.id !== id),\n        error: null,\n      }));\n\n      return true;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to delete room';\n      setState((prev) => ({ ...prev, error: message }));\n      return false;\n    }\n  }, []);\n\n  /**\n   * Get a room by ID from local state\n   */\n  const getRoomById = useCallback((id: string): RoomWithSampleCount | undefined => {\n    return state.rooms.find((room) => room.id === id);\n  }, [state.rooms]);\n\n  return {\n    state,\n    addRoom,\n    editRoom,\n    removeRoom,\n    refreshRooms,\n    getRoomById,\n  };\n}\n","/**\n * ML module type definitions\n */\n\nimport * as tf from '@tensorflow/tfjs';\n\nexport interface ModelConfig {\n  inputSize: number;           // Feature vector length (~60)\n  hiddenLayers: number[];      // Hidden layer sizes [128, 64, 32]\n  numClasses: number;          // Max 20 rooms\n  dropoutRates: number[];      // Dropout for each hidden layer [0.3, 0.2, 0]\n  learningRate: number;        // Adam optimizer learning rate\n}\n\nexport const DEFAULT_MODEL_CONFIG: Omit<ModelConfig, 'numClasses'> = {\n  inputSize: 60,\n  hiddenLayers: [128, 64, 32],\n  dropoutRates: [0.3, 0.2, 0],\n  learningRate: 0.001,\n};\n\nexport interface TrainingConfig {\n  epochs: number;\n  batchSize: number;\n  validationSplit: number;\n  earlyStopping: {\n    patience: number;\n    minDelta: number;\n  };\n  classWeights: boolean;       // Auto-compute class weights for imbalanced data\n  augmentation: {\n    enabled: boolean;\n    noiseStd: number;          // Gaussian noise standard deviation\n  };\n}\n\nexport const DEFAULT_TRAINING_CONFIG: TrainingConfig = {\n  epochs: 100,\n  batchSize: 32,\n  validationSplit: 0.2,\n  earlyStopping: {\n    patience: 10,\n    minDelta: 0.001,\n  },\n  classWeights: true,\n  augmentation: {\n    enabled: true,\n    noiseStd: 0.05,\n  },\n};\n\nexport interface TrainingProgress {\n  epoch: number;\n  totalEpochs: number;\n  loss: number;\n  accuracy: number;\n  valLoss?: number;\n  valAccuracy?: number;\n  phase: 'preparing' | 'training' | 'validating' | 'complete' | 'error';\n  message?: string;\n}\n\nexport interface TrainingResult {\n  success: boolean;\n  finalAccuracy: number;\n  finalLoss: number;\n  epochs: number;\n  history: {\n    loss: number[];\n    accuracy: number[];\n    valLoss: number[];\n    valAccuracy: number[];\n  };\n  error?: string;\n}\n\nexport interface PredictionResult {\n  predictedRoomId: string;\n  confidence: number;\n  allProbabilities: Map<string, number>;\n  isLowConfidence: boolean;\n  entropy: number;\n}\n\nexport interface ConfidenceMetrics {\n  topProbability: number;      // Softmax probability of top class\n  entropy: number;             // Entropy of probability distribution\n  margin: number;              // Difference between top 2 probabilities\n  isLowConfidence: boolean;    // Flag for uncertain predictions\n}\n\nexport interface NormalizerParams {\n  mean: number[];\n  std: number[];\n  featureCount: number;\n}\n\n// Confidence thresholds\nexport const CONFIDENCE_THRESHOLDS = {\n  LOW_CONFIDENCE_PROBABILITY: 0.6,    // Below this = low confidence\n  HIGH_ENTROPY_THRESHOLD: 1.0,        // Above this = high uncertainty\n  MIN_MARGIN_THRESHOLD: 0.2,          // Below this = ambiguous prediction\n} as const;\n\n// Type for TensorFlow model\nexport type RoomClassifierModel = tf.LayersModel;\n\n// Callback types\nexport type TrainingProgressCallback = (progress: TrainingProgress) => void;\nexport type TrainingCompleteCallback = (result: TrainingResult) => void;\n","/**\n * FeatureNormalizer - Z-score normalization for feature vectors\n *\n * Normalizes features to have zero mean and unit variance,\n * which improves neural network training stability.\n */\n\nimport { NormalizerParams } from './types';\n\nexport class FeatureNormalizer {\n  private mean: number[];\n  private std: number[];\n  private featureCount: number;\n  private fitted: boolean = false;\n\n  constructor(params?: NormalizerParams) {\n    if (params) {\n      this.mean = params.mean;\n      this.std = params.std;\n      this.featureCount = params.featureCount;\n      this.fitted = true;\n    } else {\n      this.mean = [];\n      this.std = [];\n      this.featureCount = 0;\n    }\n  }\n\n  /**\n   * Fit the normalizer to training data\n   * Computes mean and standard deviation for each feature\n   */\n  fit(features: number[][]): void {\n    if (features.length === 0) {\n      throw new Error('Cannot fit normalizer with empty data');\n    }\n\n    this.featureCount = features[0].length;\n    const n = features.length;\n\n    // Initialize accumulators\n    this.mean = new Array(this.featureCount).fill(0);\n    this.std = new Array(this.featureCount).fill(0);\n\n    // Compute mean\n    for (const sample of features) {\n      for (let i = 0; i < this.featureCount; i++) {\n        this.mean[i] += sample[i];\n      }\n    }\n    for (let i = 0; i < this.featureCount; i++) {\n      this.mean[i] /= n;\n    }\n\n    // Compute standard deviation\n    for (const sample of features) {\n      for (let i = 0; i < this.featureCount; i++) {\n        const diff = sample[i] - this.mean[i];\n        this.std[i] += diff * diff;\n      }\n    }\n    for (let i = 0; i < this.featureCount; i++) {\n      this.std[i] = Math.sqrt(this.std[i] / n);\n      // Prevent division by zero - use 1.0 for constant features\n      if (this.std[i] < 1e-10) {\n        this.std[i] = 1.0;\n      }\n    }\n\n    this.fitted = true;\n  }\n\n  /**\n   * Transform features using fitted parameters\n   * z = (x - mean) / std\n   */\n  transform(features: number[]): number[] {\n    if (!this.fitted) {\n      throw new Error('Normalizer must be fitted before transform');\n    }\n\n    if (features.length !== this.featureCount) {\n      throw new Error(\n        `Feature count mismatch: expected ${this.featureCount}, got ${features.length}`\n      );\n    }\n\n    const normalized = new Array(this.featureCount);\n    for (let i = 0; i < this.featureCount; i++) {\n      normalized[i] = (features[i] - this.mean[i]) / this.std[i];\n    }\n    return normalized;\n  }\n\n  /**\n   * Transform multiple samples\n   */\n  transformBatch(featuresBatch: number[][]): number[][] {\n    return featuresBatch.map((features) => this.transform(features));\n  }\n\n  /**\n   * Fit and transform in one step\n   */\n  fitTransform(features: number[][]): number[][] {\n    this.fit(features);\n    return this.transformBatch(features);\n  }\n\n  /**\n   * Inverse transform - convert normalized values back to original scale\n   */\n  inverseTransform(normalized: number[]): number[] {\n    if (!this.fitted) {\n      throw new Error('Normalizer must be fitted before inverse transform');\n    }\n\n    const original = new Array(this.featureCount);\n    for (let i = 0; i < this.featureCount; i++) {\n      original[i] = normalized[i] * this.std[i] + this.mean[i];\n    }\n    return original;\n  }\n\n  /**\n   * Get normalizer parameters for serialization\n   */\n  getParams(): NormalizerParams {\n    if (!this.fitted) {\n      throw new Error('Normalizer must be fitted before getting params');\n    }\n\n    return {\n      mean: [...this.mean],\n      std: [...this.std],\n      featureCount: this.featureCount,\n    };\n  }\n\n  /**\n   * Check if normalizer is fitted\n   */\n  isFitted(): boolean {\n    return this.fitted;\n  }\n\n  /**\n   * Create a normalizer from saved parameters\n   */\n  static fromParams(params: NormalizerParams): FeatureNormalizer {\n    return new FeatureNormalizer(params);\n  }\n}\n","/**\n * ConfidenceEstimator - Compute confidence metrics for predictions\n *\n * Provides multiple measures of prediction confidence:\n * - Top probability (softmax output)\n * - Entropy (uncertainty measure)\n * - Margin (difference between top 2 probabilities)\n */\n\nimport { ConfidenceMetrics, CONFIDENCE_THRESHOLDS } from './types';\n\n/**\n * Compute the entropy of a probability distribution\n * Higher entropy = more uncertainty\n */\nexport function computeEntropy(probabilities: number[]): number {\n  let entropy = 0;\n  for (const p of probabilities) {\n    if (p > 1e-10) {\n      entropy -= p * Math.log2(p);\n    }\n  }\n  return entropy;\n}\n\n/**\n * Compute the margin between top 2 probabilities\n * Lower margin = more ambiguous prediction\n */\nexport function computeMargin(probabilities: number[]): number {\n  if (probabilities.length < 2) {\n    return 1.0;\n  }\n\n  // Sort probabilities descending\n  const sorted = [...probabilities].sort((a, b) => b - a);\n  return sorted[0] - sorted[1];\n}\n\n/**\n * Compute all confidence metrics for a prediction\n */\nexport function computeConfidenceMetrics(probabilities: number[]): ConfidenceMetrics {\n  const topProbability = Math.max(...probabilities);\n  const entropy = computeEntropy(probabilities);\n  const margin = computeMargin(probabilities);\n\n  // Determine if this is a low confidence prediction\n  const isLowConfidence =\n    topProbability < CONFIDENCE_THRESHOLDS.LOW_CONFIDENCE_PROBABILITY ||\n    entropy > CONFIDENCE_THRESHOLDS.HIGH_ENTROPY_THRESHOLD ||\n    margin < CONFIDENCE_THRESHOLDS.MIN_MARGIN_THRESHOLD;\n\n  return {\n    topProbability,\n    entropy,\n    margin,\n    isLowConfidence,\n  };\n}\n\n/**\n * Get a human-readable confidence level\n */\nexport function getConfidenceLevel(\n  confidence: number\n): 'high' | 'medium' | 'low' {\n  if (confidence >= 0.8) return 'high';\n  if (confidence >= 0.6) return 'medium';\n  return 'low';\n}\n\n/**\n * Get confidence color for UI display\n */\nexport function getConfidenceColor(confidence: number): string {\n  if (confidence >= 0.8) return '#10b981'; // Green\n  if (confidence >= 0.6) return '#f59e0b'; // Yellow\n  return '#ef4444'; // Red\n}\n\n/**\n * Format confidence as percentage string\n */\nexport function formatConfidence(confidence: number): string {\n  return `${(confidence * 100).toFixed(0)}%`;\n}\n\n/**\n * Compute the maximum entropy for a given number of classes\n * (uniform distribution has maximum entropy)\n */\nexport function maxEntropy(numClasses: number): number {\n  return Math.log2(numClasses);\n}\n\n/**\n * Compute normalized entropy (0 = certain, 1 = maximum uncertainty)\n */\nexport function normalizedEntropy(\n  probabilities: number[],\n  numClasses: number\n): number {\n  const entropy = computeEntropy(probabilities);\n  const max = maxEntropy(numClasses);\n  return max > 0 ? entropy / max : 0;\n}\n\n/**\n * Determine if a prediction should be flagged for user review\n * based on multiple confidence indicators\n */\nexport function shouldFlagForReview(metrics: ConfidenceMetrics): boolean {\n  // Flag if any indicator suggests low confidence\n  return metrics.isLowConfidence;\n}\n\n/**\n * Get suggested action based on confidence\n */\nexport function getSuggestedAction(\n  metrics: ConfidenceMetrics\n): 'accept' | 'review' | 'reject' {\n  if (metrics.topProbability >= 0.8 && metrics.margin >= 0.3) {\n    return 'accept';\n  }\n  if (metrics.topProbability >= 0.5 && !metrics.isLowConfidence) {\n    return 'review';\n  }\n  return 'reject';\n}\n","/**\n * RoomClassifier - TensorFlow.js neural network for room classification\n *\n * Architecture:\n * - Input: 60 features (normalized)\n * - Hidden 1: 128 units, ReLU, Dropout(0.3)\n * - Hidden 2: 64 units, ReLU, Dropout(0.2)\n * - Hidden 3: 32 units, ReLU\n * - Output: N classes, Softmax\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport {\n  ModelConfig,\n  DEFAULT_MODEL_CONFIG,\n  PredictionResult,\n  RoomClassifierModel,\n} from './types';\nimport { FeatureNormalizer } from './FeatureNormalizer';\nimport { computeConfidenceMetrics } from './ConfidenceEstimator';\n\nexport class RoomClassifier {\n  private model: RoomClassifierModel | null = null;\n  private normalizer: FeatureNormalizer | null = null;\n  private roomLabels: string[] = [];\n  private config: ModelConfig;\n  private isReady: boolean = false;\n\n  constructor(config?: Partial<ModelConfig>) {\n    this.config = {\n      ...DEFAULT_MODEL_CONFIG,\n      numClasses: config?.numClasses ?? 2,\n      ...config,\n    };\n  }\n\n  /**\n   * Build the neural network model\n   */\n  buildModel(numClasses: number): RoomClassifierModel {\n    const { inputSize, hiddenLayers, dropoutRates, learningRate } = this.config;\n\n    const model = tf.sequential();\n\n    // Input layer + first hidden layer\n    model.add(\n      tf.layers.dense({\n        units: hiddenLayers[0],\n        activation: 'relu',\n        inputShape: [inputSize],\n        kernelInitializer: 'heNormal',\n      })\n    );\n\n    if (dropoutRates[0] > 0) {\n      model.add(tf.layers.dropout({ rate: dropoutRates[0] }));\n    }\n\n    // Additional hidden layers\n    for (let i = 1; i < hiddenLayers.length; i++) {\n      model.add(\n        tf.layers.dense({\n          units: hiddenLayers[i],\n          activation: 'relu',\n          kernelInitializer: 'heNormal',\n        })\n      );\n\n      if (dropoutRates[i] > 0) {\n        model.add(tf.layers.dropout({ rate: dropoutRates[i] }));\n      }\n    }\n\n    // Output layer\n    model.add(\n      tf.layers.dense({\n        units: numClasses,\n        activation: 'softmax',\n        kernelInitializer: 'glorotNormal',\n      })\n    );\n\n    // Compile the model\n    model.compile({\n      optimizer: tf.train.adam(learningRate),\n      loss: 'categoricalCrossentropy',\n      metrics: ['accuracy'],\n    });\n\n    return model;\n  }\n\n  /**\n   * Initialize the classifier with room labels and normalizer\n   */\n  initialize(\n    roomLabels: string[],\n    normalizer: FeatureNormalizer,\n    existingModel?: RoomClassifierModel\n  ): void {\n    this.roomLabels = roomLabels;\n    this.normalizer = normalizer;\n    this.config.numClasses = roomLabels.length;\n\n    if (existingModel) {\n      this.model = existingModel;\n    } else {\n      this.model = this.buildModel(roomLabels.length);\n    }\n\n    this.isReady = true;\n  }\n\n  /**\n   * Predict the room from a feature vector\n   */\n  async predict(features: number[]): Promise<PredictionResult> {\n    if (!this.isReady || !this.model || !this.normalizer) {\n      throw new Error('Classifier not initialized. Call initialize() first.');\n    }\n\n    // Normalize features\n    const normalized = this.normalizer.transform(features);\n\n    // Create tensor and predict\n    const inputTensor = tf.tensor2d([normalized]);\n    const predictions = this.model.predict(inputTensor) as tf.Tensor;\n    const probabilities = await predictions.data();\n\n    // Clean up tensors\n    inputTensor.dispose();\n    predictions.dispose();\n\n    // Find the predicted class\n    let maxProb = 0;\n    let maxIdx = 0;\n    const allProbabilities = new Map<string, number>();\n\n    for (let i = 0; i < probabilities.length; i++) {\n      const prob = probabilities[i];\n      const roomId = this.roomLabels[i];\n      allProbabilities.set(roomId, prob);\n\n      if (prob > maxProb) {\n        maxProb = prob;\n        maxIdx = i;\n      }\n    }\n\n    // Compute confidence metrics\n    const confidenceMetrics = computeConfidenceMetrics(Array.from(probabilities));\n\n    return {\n      predictedRoomId: this.roomLabels[maxIdx],\n      confidence: maxProb,\n      allProbabilities,\n      isLowConfidence: confidenceMetrics.isLowConfidence,\n      entropy: confidenceMetrics.entropy,\n    };\n  }\n\n  /**\n   * Predict with multiple forward passes (MC Dropout) for uncertainty estimation\n   * Note: This requires keeping dropout active during inference\n   */\n  async predictWithUncertainty(\n    features: number[],\n    numSamples: number = 10\n  ): Promise<PredictionResult & { uncertainty: number }> {\n    if (!this.isReady || !this.model || !this.normalizer) {\n      throw new Error('Classifier not initialized.');\n    }\n\n    const normalized = this.normalizer.transform(features);\n    const inputTensor = tf.tensor2d([normalized]);\n\n    // Collect predictions from multiple forward passes\n    const allPredictions: number[][] = [];\n\n    for (let i = 0; i < numSamples; i++) {\n      // Note: In TF.js, dropout is automatically disabled during inference\n      // For true MC Dropout, we'd need to use training=true, but this is\n      // a simplified version that still provides useful uncertainty estimates\n      const predictions = this.model.predict(inputTensor) as tf.Tensor;\n      const probs = await predictions.data();\n      allPredictions.push(Array.from(probs));\n      predictions.dispose();\n    }\n\n    inputTensor.dispose();\n\n    // Compute mean predictions\n    const meanPredictions = new Array(this.roomLabels.length).fill(0);\n    for (const preds of allPredictions) {\n      for (let i = 0; i < preds.length; i++) {\n        meanPredictions[i] += preds[i];\n      }\n    }\n    for (let i = 0; i < meanPredictions.length; i++) {\n      meanPredictions[i] /= numSamples;\n    }\n\n    // Compute prediction variance (uncertainty)\n    let totalVariance = 0;\n    for (const preds of allPredictions) {\n      for (let i = 0; i < preds.length; i++) {\n        const diff = preds[i] - meanPredictions[i];\n        totalVariance += diff * diff;\n      }\n    }\n    const uncertainty = Math.sqrt(totalVariance / (numSamples * this.roomLabels.length));\n\n    // Find predicted class from mean predictions\n    let maxProb = 0;\n    let maxIdx = 0;\n    const allProbabilities = new Map<string, number>();\n\n    for (let i = 0; i < meanPredictions.length; i++) {\n      const prob = meanPredictions[i];\n      allProbabilities.set(this.roomLabels[i], prob);\n      if (prob > maxProb) {\n        maxProb = prob;\n        maxIdx = i;\n      }\n    }\n\n    const confidenceMetrics = computeConfidenceMetrics(meanPredictions);\n\n    return {\n      predictedRoomId: this.roomLabels[maxIdx],\n      confidence: maxProb,\n      allProbabilities,\n      isLowConfidence: confidenceMetrics.isLowConfidence,\n      entropy: confidenceMetrics.entropy,\n      uncertainty,\n    };\n  }\n\n  /**\n   * Get the underlying TensorFlow model\n   */\n  getModel(): RoomClassifierModel | null {\n    return this.model;\n  }\n\n  /**\n   * Get room labels\n   */\n  getRoomLabels(): string[] {\n    return [...this.roomLabels];\n  }\n\n  /**\n   * Get normalizer\n   */\n  getNormalizer(): FeatureNormalizer | null {\n    return this.normalizer;\n  }\n\n  /**\n   * Check if classifier is ready for predictions\n   */\n  ready(): boolean {\n    return this.isReady;\n  }\n\n  /**\n   * Serialize model to JSON and weights\n   */\n  async serialize(): Promise<{ topology: unknown; weights: ArrayBuffer }> {\n    if (!this.model) {\n      throw new Error('No model to serialize');\n    }\n\n    // Get model topology (returns string | PyJsonDict)\n    const topology = this.model.toJSON();\n\n    // Get weights as ArrayBuffer\n    const weightData = await this.model.getWeights();\n    const weightArrays: Float32Array[] = [];\n\n    for (const tensor of weightData) {\n      const data = await tensor.data();\n      weightArrays.push(new Float32Array(data));\n    }\n\n    // Concatenate all weights\n    const totalLength = weightArrays.reduce((sum, arr) => sum + arr.length, 0);\n    const concatenated = new Float32Array(totalLength);\n    let offset = 0;\n    for (const arr of weightArrays) {\n      concatenated.set(arr, offset);\n      offset += arr.length;\n    }\n\n    return {\n      topology,\n      weights: concatenated.buffer,\n    };\n  }\n\n  /**\n   * Load model from serialized data\n   */\n  async deserialize(\n    topology: unknown,\n    weights: ArrayBuffer,\n    roomLabels: string[],\n    normalizerParams: { mean: number[]; std: number[]; featureCount: number }\n  ): Promise<void> {\n    // Load model from JSON\n    this.model = await tf.models.modelFromJSON(topology as tf.io.ModelJSON);\n\n    // Set weights\n    const weightData = new Float32Array(weights);\n    const modelWeights = this.model.getWeights();\n\n    let offset = 0;\n    const newWeights: tf.Tensor[] = [];\n\n    for (const tensor of modelWeights) {\n      const shape = tensor.shape;\n      const size = shape.reduce((a, b) => a * b, 1);\n      const data = weightData.slice(offset, offset + size);\n      newWeights.push(tf.tensor(data, shape));\n      offset += size;\n    }\n\n    this.model.setWeights(newWeights);\n\n    // Clean up temporary tensors\n    for (const tensor of newWeights) {\n      tensor.dispose();\n    }\n\n    // Set room labels and normalizer\n    this.roomLabels = roomLabels;\n    this.normalizer = FeatureNormalizer.fromParams(normalizerParams);\n    this.config.numClasses = roomLabels.length;\n    this.isReady = true;\n  }\n\n  /**\n   * Dispose of TensorFlow resources\n   */\n  dispose(): void {\n    if (this.model) {\n      this.model.dispose();\n      this.model = null;\n    }\n    this.isReady = false;\n  }\n}\n","/**\n * ModelTrainer - Training pipeline for room classifier\n *\n * Handles:\n * - Data preparation and augmentation\n * - Class weight computation for imbalanced data\n * - Training with early stopping\n * - Progress callbacks for UI updates\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport {\n  TrainingConfig,\n  DEFAULT_TRAINING_CONFIG,\n  TrainingProgress,\n  TrainingResult,\n  TrainingProgressCallback,\n} from './types';\nimport { RoomClassifier } from './RoomClassifier';\nimport { FeatureNormalizer } from './FeatureNormalizer';\n\nexport class ModelTrainer {\n  private config: TrainingConfig;\n  private progressCallback?: TrainingProgressCallback;\n\n  constructor(config?: Partial<TrainingConfig>) {\n    this.config = {\n      ...DEFAULT_TRAINING_CONFIG,\n      ...config,\n    };\n  }\n\n  /**\n   * Set progress callback for UI updates\n   */\n  onProgress(callback: TrainingProgressCallback): void {\n    this.progressCallback = callback;\n  }\n\n  /**\n   * Report progress to callback\n   */\n  private reportProgress(progress: TrainingProgress): void {\n    if (this.progressCallback) {\n      this.progressCallback(progress);\n    }\n  }\n\n  /**\n   * Prepare training data\n   * - Normalizes features\n   * - Converts labels to one-hot encoding\n   * - Applies data augmentation if enabled\n   */\n  prepareData(\n    features: number[][],\n    labels: string[],\n    roomLabels: string[]\n  ): {\n    normalizer: FeatureNormalizer;\n    trainX: tf.Tensor2D;\n    trainY: tf.Tensor2D;\n  } {\n    this.reportProgress({\n      epoch: 0,\n      totalEpochs: this.config.epochs,\n      loss: 0,\n      accuracy: 0,\n      phase: 'preparing',\n      message: 'Normalizing features...',\n    });\n\n    // Fit normalizer and transform features\n    const normalizer = new FeatureNormalizer();\n    const normalizedFeatures = normalizer.fitTransform(features);\n\n    // Apply data augmentation if enabled\n    let augmentedFeatures = normalizedFeatures;\n    let augmentedLabels = labels;\n\n    if (this.config.augmentation.enabled) {\n      this.reportProgress({\n        epoch: 0,\n        totalEpochs: this.config.epochs,\n        loss: 0,\n        accuracy: 0,\n        phase: 'preparing',\n        message: 'Augmenting data...',\n      });\n\n      const { features: augFeats, labels: augLabs } = this.augmentData(\n        normalizedFeatures,\n        labels\n      );\n      augmentedFeatures = augFeats;\n      augmentedLabels = augLabs;\n    }\n\n    // Convert labels to one-hot encoding\n    const labelIndices = augmentedLabels.map((label) =>\n      roomLabels.indexOf(label)\n    );\n    const numClasses = roomLabels.length;\n\n    // Create tensors\n    const trainX = tf.tensor2d(augmentedFeatures);\n    const trainY = tf.oneHot(tf.tensor1d(labelIndices, 'int32'), numClasses);\n\n    return {\n      normalizer,\n      trainX,\n      trainY: trainY as tf.Tensor2D,\n    };\n  }\n\n  /**\n   * Augment training data by adding Gaussian noise\n   */\n  private augmentData(\n    features: number[][],\n    labels: string[]\n  ): { features: number[][]; labels: string[] } {\n    const augmentedFeatures: number[][] = [...features];\n    const augmentedLabels: string[] = [...labels];\n    const noiseStd = this.config.augmentation.noiseStd;\n\n    // Add 1 augmented copy per original sample\n    for (let i = 0; i < features.length; i++) {\n      const noisy = features[i].map(\n        (val) => val + (Math.random() - 0.5) * 2 * noiseStd\n      );\n      augmentedFeatures.push(noisy);\n      augmentedLabels.push(labels[i]);\n    }\n\n    return { features: augmentedFeatures, labels: augmentedLabels };\n  }\n\n  /**\n   * Compute class weights for imbalanced data\n   */\n  computeClassWeights(labels: string[], roomLabels: string[]): { [key: number]: number } {\n    const counts = new Map<string, number>();\n    for (const label of labels) {\n      counts.set(label, (counts.get(label) || 0) + 1);\n    }\n\n    const totalSamples = labels.length;\n    const numClasses = roomLabels.length;\n    const weights: { [key: number]: number } = {};\n\n    for (let i = 0; i < roomLabels.length; i++) {\n      const count = counts.get(roomLabels[i]) || 1;\n      // Balanced class weight formula\n      weights[i] = totalSamples / (numClasses * count);\n    }\n\n    return weights;\n  }\n\n  /**\n   * Train the classifier\n   */\n  async train(\n    classifier: RoomClassifier,\n    features: number[][],\n    labels: string[],\n    roomLabels: string[]\n  ): Promise<TrainingResult> {\n    try {\n      // Prepare data\n      const { normalizer, trainX, trainY } = this.prepareData(\n        features,\n        labels,\n        roomLabels\n      );\n\n      // Initialize classifier\n      classifier.initialize(roomLabels, normalizer);\n      const model = classifier.getModel();\n\n      if (!model) {\n        throw new Error('Failed to create model');\n      }\n\n      // Compute class weights if enabled\n      let classWeights: { [key: number]: number } | undefined;\n      if (this.config.classWeights) {\n        classWeights = this.computeClassWeights(labels, roomLabels);\n      }\n\n      // Training history\n      const history = {\n        loss: [] as number[],\n        accuracy: [] as number[],\n        valLoss: [] as number[],\n        valAccuracy: [] as number[],\n      };\n\n      // Early stopping state\n      let bestValLoss = Infinity;\n      let patienceCounter = 0;\n\n      this.reportProgress({\n        epoch: 0,\n        totalEpochs: this.config.epochs,\n        loss: 0,\n        accuracy: 0,\n        phase: 'training',\n        message: 'Starting training...',\n      });\n\n      // Custom training loop for better control\n      for (let epoch = 0; epoch < this.config.epochs; epoch++) {\n        // Train for one epoch\n        const result = await model.fit(trainX, trainY, {\n          epochs: 1,\n          batchSize: this.config.batchSize,\n          validationSplit: this.config.validationSplit,\n          classWeight: classWeights,\n          shuffle: true,\n          verbose: 0,\n        });\n\n        const loss = result.history.loss[0] as number;\n        const accuracy = result.history.acc[0] as number;\n        const valLoss = result.history.val_loss?.[0] as number | undefined;\n        const valAccuracy = result.history.val_acc?.[0] as number | undefined;\n\n        // Update history\n        history.loss.push(loss);\n        history.accuracy.push(accuracy);\n        if (valLoss !== undefined) history.valLoss.push(valLoss);\n        if (valAccuracy !== undefined) history.valAccuracy.push(valAccuracy);\n\n        // Report progress\n        this.reportProgress({\n          epoch: epoch + 1,\n          totalEpochs: this.config.epochs,\n          loss,\n          accuracy,\n          valLoss,\n          valAccuracy,\n          phase: 'training',\n        });\n\n        // Early stopping check\n        if (valLoss !== undefined) {\n          if (valLoss < bestValLoss - this.config.earlyStopping.minDelta) {\n            bestValLoss = valLoss;\n            patienceCounter = 0;\n          } else {\n            patienceCounter++;\n            if (patienceCounter >= this.config.earlyStopping.patience) {\n              this.reportProgress({\n                epoch: epoch + 1,\n                totalEpochs: this.config.epochs,\n                loss,\n                accuracy,\n                valLoss,\n                valAccuracy,\n                phase: 'complete',\n                message: `Early stopping at epoch ${epoch + 1}`,\n              });\n              break;\n            }\n          }\n        }\n      }\n\n      // Clean up tensors\n      trainX.dispose();\n      trainY.dispose();\n\n      const finalAccuracy = history.valAccuracy.length > 0\n        ? history.valAccuracy[history.valAccuracy.length - 1]\n        : history.accuracy[history.accuracy.length - 1];\n\n      const finalLoss = history.valLoss.length > 0\n        ? history.valLoss[history.valLoss.length - 1]\n        : history.loss[history.loss.length - 1];\n\n      this.reportProgress({\n        epoch: history.loss.length,\n        totalEpochs: this.config.epochs,\n        loss: finalLoss,\n        accuracy: finalAccuracy,\n        phase: 'complete',\n        message: `Training complete! Accuracy: ${(finalAccuracy * 100).toFixed(1)}%`,\n      });\n\n      return {\n        success: true,\n        finalAccuracy,\n        finalLoss,\n        epochs: history.loss.length,\n        history,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n      this.reportProgress({\n        epoch: 0,\n        totalEpochs: this.config.epochs,\n        loss: 0,\n        accuracy: 0,\n        phase: 'error',\n        message: `Training failed: ${errorMessage}`,\n      });\n\n      return {\n        success: false,\n        finalAccuracy: 0,\n        finalLoss: 0,\n        epochs: 0,\n        history: {\n          loss: [],\n          accuracy: [],\n          valLoss: [],\n          valAccuracy: [],\n        },\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Evaluate model on test data\n   */\n  async evaluate(\n    classifier: RoomClassifier,\n    features: number[][],\n    labels: string[]\n  ): Promise<{ accuracy: number; confusionMatrix: number[][] }> {\n    const roomLabels = classifier.getRoomLabels();\n    const numClasses = roomLabels.length;\n\n    // Initialize confusion matrix\n    const confusionMatrix: number[][] = Array(numClasses)\n      .fill(null)\n      .map(() => Array(numClasses).fill(0));\n\n    let correct = 0;\n\n    for (let i = 0; i < features.length; i++) {\n      const prediction = await classifier.predict(features[i]);\n      const predictedIdx = roomLabels.indexOf(prediction.predictedRoomId);\n      const actualIdx = roomLabels.indexOf(labels[i]);\n\n      confusionMatrix[actualIdx][predictedIdx]++;\n\n      if (predictedIdx === actualIdx) {\n        correct++;\n      }\n    }\n\n    return {\n      accuracy: correct / features.length,\n      confusionMatrix,\n    };\n  }\n}\n","/**\n * useRoomClassifier - React hook for ML model training and prediction\n *\n * Provides:\n * - Model training with progress updates\n * - Room prediction from features\n * - Model persistence to IndexedDB\n * - Model loading from storage\n */\n\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport {\n  RoomClassifier,\n  ModelTrainer,\n  TrainingProgress,\n  TrainingResult,\n  PredictionResult,\n} from '../ml';\nimport {\n  saveModel,\n  getModel,\n  hasModel,\n  deleteModel,\n} from '../storage';\n\nexport type ModelState = 'none' | 'loading' | 'ready' | 'training' | 'error';\n\nexport interface UseRoomClassifierState {\n  modelState: ModelState;\n  isTraining: boolean;\n  trainingProgress: TrainingProgress | null;\n  lastTrainingResult: TrainingResult | null;\n  modelInfo: {\n    roomCount: number;\n    accuracy: number;\n    createdAt: number;\n  } | null;\n  error: string | null;\n}\n\nexport interface UseRoomClassifierReturn {\n  state: UseRoomClassifierState;\n  train: (\n    features: number[][],\n    labels: string[],\n    roomIds: string[]\n  ) => Promise<TrainingResult>;\n  predict: (features: number[]) => Promise<PredictionResult | null>;\n  loadModel: () => Promise<boolean>;\n  clearModel: () => Promise<boolean>;\n  hasTrainedModel: () => Promise<boolean>;\n}\n\nexport function useRoomClassifier(): UseRoomClassifierReturn {\n  const [state, setState] = useState<UseRoomClassifierState>({\n    modelState: 'none',\n    isTraining: false,\n    trainingProgress: null,\n    lastTrainingResult: null,\n    modelInfo: null,\n    error: null,\n  });\n\n  const classifierRef = useRef<RoomClassifier | null>(null);\n  const trainerRef = useRef<ModelTrainer | null>(null);\n\n  // Initialize trainer\n  useEffect(() => {\n    trainerRef.current = new ModelTrainer();\n\n    // Check for existing model on mount\n    loadModelFromStorage();\n\n    return () => {\n      if (classifierRef.current) {\n        classifierRef.current.dispose();\n      }\n    };\n  }, []);\n\n  /**\n   * Load model from IndexedDB storage\n   */\n  const loadModelFromStorage = async (): Promise<boolean> => {\n    setState((prev) => ({ ...prev, modelState: 'loading', error: null }));\n\n    try {\n      const storedModel = await getModel();\n\n      if (!storedModel) {\n        setState((prev) => ({ ...prev, modelState: 'none' }));\n        return false;\n      }\n\n      // Create new classifier and deserialize\n      const classifier = new RoomClassifier();\n      await classifier.deserialize(\n        storedModel.topology,\n        storedModel.weights,\n        storedModel.roomLabels,\n        storedModel.normalizer\n      );\n\n      classifierRef.current = classifier;\n\n      setState((prev) => ({\n        ...prev,\n        modelState: 'ready',\n        modelInfo: {\n          roomCount: storedModel.roomLabels.length,\n          accuracy: storedModel.metadata.accuracy,\n          createdAt: storedModel.createdAt,\n        },\n      }));\n\n      return true;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to load model';\n      console.error('Failed to load model:', error);\n      setState((prev) => ({\n        ...prev,\n        modelState: 'error',\n        error: message,\n      }));\n      return false;\n    }\n  };\n\n  /**\n   * Train a new model\n   */\n  const train = useCallback(async (\n    features: number[][],\n    labels: string[],\n    roomIds: string[]\n  ): Promise<TrainingResult> => {\n    setState((prev) => ({\n      ...prev,\n      modelState: 'training',\n      isTraining: true,\n      trainingProgress: null,\n      lastTrainingResult: null,\n      error: null,\n    }));\n\n    try {\n      // Dispose existing classifier\n      if (classifierRef.current) {\n        classifierRef.current.dispose();\n      }\n\n      // Create new classifier and trainer\n      const classifier = new RoomClassifier();\n      const trainer = trainerRef.current || new ModelTrainer();\n\n      // Set up progress callback\n      trainer.onProgress((progress) => {\n        setState((prev) => ({ ...prev, trainingProgress: progress }));\n      });\n\n      // Train the model\n      const result = await trainer.train(classifier, features, labels, roomIds);\n\n      if (result.success) {\n        // Save model to storage\n        const { topology, weights } = await classifier.serialize();\n        const normalizer = classifier.getNormalizer();\n\n        if (normalizer) {\n          await saveModel(\n            topology as object,\n            weights,\n            roomIds,\n            normalizer.getParams(),\n            {\n              accuracy: result.finalAccuracy,\n              loss: result.finalLoss,\n              epochs: result.epochs,\n              samplesUsed: features.length,\n              roomCount: roomIds.length,\n            }\n          );\n        }\n\n        classifierRef.current = classifier;\n\n        setState((prev) => ({\n          ...prev,\n          modelState: 'ready',\n          isTraining: false,\n          lastTrainingResult: result,\n          modelInfo: {\n            roomCount: roomIds.length,\n            accuracy: result.finalAccuracy,\n            createdAt: Date.now(),\n          },\n        }));\n      } else {\n        setState((prev) => ({\n          ...prev,\n          modelState: 'error',\n          isTraining: false,\n          lastTrainingResult: result,\n          error: result.error || 'Training failed',\n        }));\n      }\n\n      return result;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Training failed';\n      const failedResult: TrainingResult = {\n        success: false,\n        finalAccuracy: 0,\n        finalLoss: 0,\n        epochs: 0,\n        history: { loss: [], accuracy: [], valLoss: [], valAccuracy: [] },\n        error: message,\n      };\n\n      setState((prev) => ({\n        ...prev,\n        modelState: 'error',\n        isTraining: false,\n        lastTrainingResult: failedResult,\n        error: message,\n      }));\n\n      return failedResult;\n    }\n  }, []);\n\n  /**\n   * Predict room from features\n   */\n  const predict = useCallback(async (features: number[]): Promise<PredictionResult | null> => {\n    if (!classifierRef.current || !classifierRef.current.ready()) {\n      setState((prev) => ({\n        ...prev,\n        error: 'No model loaded. Train a model first.',\n      }));\n      return null;\n    }\n\n    try {\n      const result = await classifierRef.current.predict(features);\n      return result;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Prediction failed';\n      setState((prev) => ({ ...prev, error: message }));\n      return null;\n    }\n  }, []);\n\n  /**\n   * Load model from storage (public API)\n   */\n  const loadModel = useCallback(async (): Promise<boolean> => {\n    return loadModelFromStorage();\n  }, []);\n\n  /**\n   * Clear the trained model\n   */\n  const clearModel = useCallback(async (): Promise<boolean> => {\n    try {\n      await deleteModel();\n\n      if (classifierRef.current) {\n        classifierRef.current.dispose();\n        classifierRef.current = null;\n      }\n\n      setState((prev) => ({\n        ...prev,\n        modelState: 'none',\n        modelInfo: null,\n        lastTrainingResult: null,\n        error: null,\n      }));\n\n      return true;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to clear model';\n      setState((prev) => ({ ...prev, error: message }));\n      return false;\n    }\n  }, []);\n\n  /**\n   * Check if a trained model exists\n   */\n  const hasTrainedModel = useCallback(async (): Promise<boolean> => {\n    return await hasModel();\n  }, []);\n\n  return {\n    state,\n    train,\n    predict,\n    loadModel,\n    clearModel,\n    hasTrainedModel,\n  };\n}\n"],"names":["instanceOfAny","object","constructors","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","getCursorAdvanceMethods","cursorRequestMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","resolve","reject","unlisten","success","error","wrap","value","cacheDonePromiseForTransaction","tx","done","complete","idbProxyTraps","target","prop","receiver","replaceTraps","callback","wrapFunction","func","storeNames","args","unwrap","transformCachableValue","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","openPromise","event","db","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","storeName","oldTraps","DB_VERSION","DB_NAME","STORES","dbInstance","getDatabase","oldVersion","newVersion","_transaction","roomStore","sampleStore","getRandomValues","rnds8","rng","byteToHex","i","unsafeStringify","arr","offset","randomUUID","native","v4","options","buf","rnds","createRoom","room","uuidv4","getRoom","id","getAllRooms","updateRoom","updates","existing","updated","deleteRoom","cursor","roomNameExists","createSample","roomId","features","metadata","sample","getSamplesForRoom","getAllSamples","getSampleCountsByRoom","samples","counts","current","deleteSample","deleteSamplesForRoom","count","getTrainingData","labels","roomIdSet","canTrain","minSamplesPerRoom","roomCount","readyRooms","totalSamples","canTrainResult","message","MODEL_ID","saveModel","topology","weights","roomLabels","normalizer","storedModel","getModel","hasModel","deleteModel","useRooms","state","setState","useState","refreshRooms","useCallback","prev","rooms","sampleCounts","roomsWithCounts","a","b","useEffect","addRoom","editRoom","currentRoom","removeRoom","getRoomById","DEFAULT_MODEL_CONFIG","DEFAULT_TRAINING_CONFIG","CONFIDENCE_THRESHOLDS","FeatureNormalizer","params","__publicField","n","diff","normalized","featuresBatch","original","computeEntropy","probabilities","entropy","p","computeMargin","sorted","computeConfidenceMetrics","topProbability","margin","isLowConfidence","RoomClassifier","config","numClasses","inputSize","hiddenLayers","dropoutRates","learningRate","model","tf.sequential","tf.layers.dense","tf.layers.dropout","tf.train","existingModel","inputTensor","tf.tensor2d","predictions","maxProb","maxIdx","allProbabilities","prob","confidenceMetrics","numSamples","allPredictions","probs","meanPredictions","preds","totalVariance","uncertainty","weightData","weightArrays","tensor","data","totalLength","sum","concatenated","normalizerParams","tf.models.modelFromJSON","modelWeights","newWeights","shape","size","tf.tensor","ModelTrainer","progress","normalizedFeatures","augmentedFeatures","augmentedLabels","augFeats","augLabs","labelIndices","label","trainX","trainY","tf.oneHot","tf.tensor1d","noiseStd","noisy","val","classifier","classWeights","history","bestValLoss","patienceCounter","epoch","result","loss","accuracy","valLoss","_a","valAccuracy","_b","finalAccuracy","finalLoss","errorMessage","confusionMatrix","correct","prediction","predictedIdx","actualIdx","useRoomClassifier","classifierRef","useRef","trainerRef","loadModelFromStorage","train","roomIds","trainer","failedResult","predict","loadModel","clearModel","hasTrainedModel"],"mappings":"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","x_google_ignoreList":[0,1,4,5,6,7]}